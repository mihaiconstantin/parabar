[{"path":"http://parabar.mihaiconstantin.com/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Mihai . Constantin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Comparison with other approaches","text":"goal article compare parabar package packages available CRAN provide progress tracking functionality parallelized R code. parabar provides features, comparisons benchmarks presented article specifically aimed progress-tracking functionality. remainder article organized follows. start section parabar tackles progress tracking. , iterate packages provide progress tracking parallel tasks briefly discuss approaches packages employ. Next, provide rough benchmarks comparing added overhead progress-tracking approaches baseline scenario using built-package parallel (.e., without progress tracking).","code":""},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"progress-tracking-with-parabar","dir":"Articles","previous_headings":"","what":"Progress tracking with parabar","title":"Comparison with other approaches","text":"parabar package aimed two audiences: (1) end-users intend use package scripts executed interactive R session (.e., see resource), (2) R package developers (.e., see resource). two key concepts behind parabar backends contexts. describe concepts detail demonstrate can used add new functionality parabar. example focused progress tracking, represents one example possible. may check UML diagram detailed overview package design.","code":""},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"backends","dir":"Articles","previous_headings":"Progress tracking with parabar","what":"Backends","title":"Comparison with other approaches","text":"backend R6 class wrapper around cluster object obtained ?parallel::makeCluster function. role backend abide standardized way interacting parallel clusters implementing ?Service interface. nutshell, ?Service interface defines set operations backend can perform cluster object (e.g., exporting variables, evaluating expressions, running parallel tasks etc.). Backends can different types. Currently, parabar supports synchronous asynchronous backends. synchronous backend manages cluster created process backend instance . asynchronous backend, hand, manages cluster created background R session (.e., created via callr package). principle, possible extend parabar types backends (e.g., backends created remote server managed SSH).","code":""},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"contexts","dir":"Articles","previous_headings":"Progress tracking with parabar","what":"Contexts","title":"Comparison with other approaches","text":"parabar package designed extensibility mind, brings us second key concept, namely, contexts. New functionality can implemented custom contexts extend base context class. simple terms, context R6 wrapper class backend instance, role determining backend operations defined ?Service interface executed. base ?Context (.e., custom contexts extend) implements ?Service backend instance simply forwards method calls backend instance, turn interacts cluster. example, calling sapply method base ?Context instance forward call corresponding sapply method wrapped ?Backend instance, contains actual implementation details interacting cluster object (e.g., via ?parallel::parSapply).","code":""},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"progress-tracking-functionality","dir":"Articles","previous_headings":"Progress tracking with parabar","what":"Progress tracking functionality","title":"Comparison with other approaches","text":"New functionality can added creating custom contexts extends base context. Custom contexts can override decorate methods base context provide desired functionality. ?ProgressTrackingContext example custom context decorates sapply method add progress tracking. specific context works overriding sapply method base ?Context class add necessary functionality progress tracking. specifically, take look source code sapply method base ?Context see following: method simply passes arguments sapply method wrapped backend instance (.e., stored private field .backend). Note ?Backend ?Context classes share sapply method since implement ?Service interface requires provide implementation method. custom ?ProgressTrackingContext can override sapply method provide progress-tracking capabilities follows: Breaking implementation , following lines code create temporary file task function record progress task execution, remove file parallel task completed. next line code decorates task function injecting code enables record progress log file execution. Next, call sapply method base ?Context class (.e., via super access modifier) pass decorated task function. mentioned earlier, call simply forwarded sapply method .backend instance. However, unlike , task function now decorated log progress file. Finally, following line code simply creates ?Bar instance display update progress bar based progress reported log file (.e., see source code ). summary, parabar enables progress-tracking parallel tasks adjusting task function log file time task finished executing. log file monitored periodically used update progress bar displayed console (.e., see also progress_timeout field ?Options adjust timeout subsequent checks log file). benefits approach two fold. First, progress bar accurately reflect execution progress task. Second, scales well kind tasks (.e., simple complex). hand, one potential disadvantage approach overhead associated /O writing reading execution progress.","code":"# ...  sapply = function(x, fun, ...) {     # Consume the backend API.     private$.backend$sapply(x = x, fun = fun, ...) }  # ... # ... sapply = function(x, fun, ...) {     # Create file for logging progress.     log <- private$.make_log()      # Clear the temporary file on function exit.     on.exit(unlink(log))      # Decorate task function.     task <- private$.decorate(task = fun, log = log)      # Execute the decorated task.     super$sapply(x = x, fun = task, ...)      # Show the progress bar and block the main process.     private$.show_progress(total = length(x), log = log) } # ... # Create file for logging progress. log <- private$.make_log()  # Clear the temporary file on function exit. on.exit(unlink(log)) # Decorate task function. task <- private$.decorate(task = fun, log = log) # Execute the decorated task. super$sapply(x = x, fun = task, ...) # Show the progress bar and block the main process. private$.show_progress(total = length(x), log = log)"},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"progress-tracking-with-pbapply","dir":"Articles","previous_headings":"","what":"Progress tracking with pbapply","title":"Comparison with other approaches","text":"pbapply versatile package provides progress tracking various backends vectorized R functions *apply family. understand pbapply approaches progress tracking, can take look implementation details ?pbapply::pblapply function, seems workhorse function used *apply variants. time writing article, recent version function ?pbapply::pblapply commit ed40554 December 10, 2022, file pblapply.R. Looking source code lines 46 61 file pblapply.R see following code: Line 46 code snippet used determine whether parallel backend cluster object created via parallel package. case, pbapply proceeds lines 47 48 choosing appropriate ?parallel::parLapply function parallelization (.e., without load balancing). , lines 50 51 determine whether progress bar displayed based dopb function. interesting part, represented lines 52 61, used define progress bar created updated. specifically, line 53 splits task repetitions smaller chunks based many tasks want run (.e., nx), many nodes cluster (.e., ncl), maximum number splits want (.e., nout). example, suppose want want run 2020 tasks parallel cluster three nodes, default value nout = NULL. case, pbapply creates following splits: see ?pbapply::splitpb produced seven splits, consisting two three task repetitions. lines 54 55 pbapply counts many splits created starts progress bar minimum zero maximum value set total number splits (.e., seven case). Even interesting lines 58 61. , pbapply loops split calls selected parallel function (e.g., ?parallel::parLapply) task repetitions corresponding current split processed. soon parallel function returns, progress bar updated processed split index. Therefore, example , pbapply call parallel function seven times, hence update progress bar seven times. code snippet already provides us two important insights pbapply works. First, default, pbapply update progress bar task repetition. Second, overhead pbapply adds likely given repeated calls parallel function (e.g., ?parallel::parLapply) involves transferring tasks different processes make cluster nodes. can compare source code built-function ?parallel::parLapply displayed , let X represent 2020 task repetitions fun task function applied repetition: can see lines 3 12 calls two internal functions parallel package, namely, parallel:::staticNChunks parallel:::splitList. Applying functions example results following splits: see pbapply uses similar approach creating task splits, however, unlike pbapply, built-parallel package creates default many tasks splits nodes cluster. means ?parallel::clusterApply function used within ?parallel::parLapply called three times, .e., stated documentation: clusterApply calls fun first node arguments x[[1]] …, second node x[[2]] …, , recycling nodes needed. approach strikingly different pbapply , example, results calling parallel function (e.g., ?parallel::parLapply) seven times, , turn, results calling ?parallel::clusterApply individual task repetition. Put simply, example , parallel package calls ?parallel::clusterApply chunk, whereas pbapply calls ?parallel::clusterApply task repetition. Therefore, pbapply progress tracking functionality can regarded tradeoff granularity progress bar overhead associated chunking task repetitions communicating cluster nodes. overhead likely negligible number tasks low, repeated calls ?parallel::clusterApply definitely something one consider scaling things . next section, provide rough estimates overhead associated progress-tracking approaches discussed .","code":"# ...                                                           # 45 if (inherits(cl, \"cluster\")) {                                  # 46     ## switch on load balancing if needed                       # 47     PAR_FUN <- if (isTRUE(getOption(\"pboptions\")$use_lb))       # 48         parallel::parLapplyLB else parallel::parLapply          # 49     if (!dopb())                                                # 50         return(PAR_FUN(cl, X, FUN, ...))                        # 51     ## define split here and use that for counter               # 52     Split <- splitpb(length(X), length(cl), nout = nout)        # 53     B <- length(Split)                                          # 54     pb <- startpb(0, B)                                         # 55     on.exit(closepb(pb), add = TRUE)                            # 56     rval <- vector(\"list\", B)                                   # 57     for (i in seq_len(B)) {                                     # 58         rval[i] <- list(PAR_FUN(cl, X[Split[[i]]], FUN, ...))   # 59         setpb(pb, i)                                            # 60     }                                                           # 61 } # ...                                                         # 62 # Create task splits. splits <- pbapply::splitpb(nx = 20, ncl = 3, nout = NULL)  # Print the splits. print(splits) #> [[1]] #> [1] 1 2 3 #> #> [[2]] #> [1] 4 5 6 #> #> [[3]] #> [1] 7 8 9 #> #> [[4]] #> [1] 10 11 12 #> #> [[5]] #> [1] 13 14 15 #> #> [[6]] #> [1] 16 17 18 #> #> [[7]] #> [1] 19 20 function(cl = NULL, X, fun, ..., chunk.size = NULL) {   # 1     cl <- defaultCluster(cl)                            # 2     nchunks <- parallel:::staticNChunks(                # 3         length(X),                                      # 4         length(cl),                                     # 5         chunk.size                                      # 6     )                                                   # 7     do.call(                                            # 8         c,                                              # 9         clusterApply(                                   # 10             cl = cl,                                    # 11             x = parallel:::splitList(X, nchunks),       # 12             fun = lapply,                               # 13             FUN = fun,                                  # 14             ...                                         # 15         ),                                              # 16         quote = TRUE                                    # 17     )                                                   # 18 }                                                       # 19 # Task repetitions. X <- 1:20  # Number of nodes in the cluster. ncl <- 3  # Compute chunk size based on that repetitions and cluster size. nchunks <- parallel:::staticNChunks(length(X), ncl, NULL)  # Print the chunk size. print(nchunks) #> [1] 3  # Create the task splits. parallel:::splitList(X, nchunks) #> [[1]] #> [1] 1 2 3 4 5 6 7 #> #> [[2]] #> [1]  8  9 10 11 12 13 #> #> [[3]] #> [1] 14 15 16 17 18 19 20"},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"overhead","dir":"Articles","previous_headings":"","what":"Overhead","title":"Comparison with other approaches","text":"make things comparable possible, start defining dummy task function can reliably measure long takes execute. run 10001000 repetitions task parallel via built-function ?parallel::parSapply establish baseline execution time. baseline execution time serves benchmark comparing execution times progress-tracking approaches discussed (e.g., pbapply parabar). obtain stable results, determine execution times based 100100 replications parallelized task replications, provide summary form figure. achieve , use microbenchmark package benchmarking execution times, ggplot2 package plotting results.","code":""},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"the-task-function","dir":"Articles","previous_headings":"Overhead","what":"The task function","title":"Comparison with other approaches","text":"start loading libraries needed benchmarks . task, can use ?base::Sys.sleep function simulate task takes certain amount time execute. purposes article, use task takes roughly 0.050.05 milliseconds execute simply adds one input argument.","code":"# Load libraries. library(parallel) library(parabar) library(pbapply) library(microbenchmark) library(ggplot2) # Define task function. task <- function(x) {     # Pretend to perform an expensive computation.     Sys.sleep(0.00005)      # Return the computation.     return(x + 1) }"},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"baseline-execution-time","dir":"Articles","previous_headings":"Overhead","what":"Baseline execution time","title":"Comparison with other approaches","text":"Suppose want 10001000 repetitions task function executed parallel cluster consisting five nodes. determine execution time based ?parallel::parSapply function, serve benchmark. can establish benchmark using following code: Running task parallel via ?parallel::parSapply function takes average M=15.14M = 15.14 milliseconds, standard deviation SD=1.04SD = 1.04.","code":"# Define the task repetitions. n_tasks <- 1:1000  # Define the benchmark repetitions. n_benchmarks <- 100  # Create a cluster of five nodes. cluster <- makeCluster(spec = 5, type = \"PSOCK\")  # Measure the execution time of the task function. duration_parallel <- microbenchmark(     # The task to benchmark.     parallel = parSapply(cluster, X = n_tasks, FUN = task),      # Benchmark repetitions.     times = n_benchmarks )  # Stop the cluster. stopCluster(cluster)  # Print the duration. print(duration_parallel, unit = \"ms\") #> Unit: milliseconds #>      expr      min       lq     mean   median       uq      max neval #>  parallel 14.65648 14.84083 15.14253 14.96682 15.09481 24.25228   100"},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"parabar-execution-time","dir":"Articles","previous_headings":"Overhead","what":"parabar execution time","title":"Comparison with other approaches","text":"repeat setup , time using parabar package. Since end-user API prevents us displaying progress bars non-interactive sessions (e.g., knitting R vignettes), can, conveniently, use R6 developer API force progress-tracking, nevertheless. case, use ?parabar::ProgressTrackingContext adds progress tracking functionality tasks executed parallel. avoid issues progress bar displaying correctly non-interactive R session, temporarily redirect progress bar output /dev/null using ?base::sink function. Note progress tracking functionality still employed (.e., logging execution progress file reading file update progress bar), progress bar displayed. Based results , observe running task function parallel via parabar, progress tracking, yields execution time M=85.73M = 85.73 milliseconds, SD=13.21SD = 13.21. Therefore, overhead parabar relative parallel roughly 70.5870.58 milliseconds.","code":"# Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 5)  # Set the cluster type. specification$set_type(type = \"psock\")  # Get a backend instance that does support progress tracking. backend <- AsyncBackend$new()  # Create a progress-tracking context object. context <- ProgressTrackingContext$new()  # Register the backend with the context. context$set_backend(backend)  # Start the backend. context$start(specification)  # Get a modern bar instance. bar <- BasicBar$new()  # Register the bar with the context. context$set_bar(bar)  # Measure the execution time of the task function. duration_parabar <- microbenchmark(     # The task to benchmark.     parabar = {         # Redirect the output.         sink(\"/dev/null\")          # Run a task in parallel.         context$sapply(x = n_tasks, fun = task)          # Get the task output.         backend$get_output(wait = TRUE)          # Disable the output redirection.         sink()     },      # Benchmark repetitions.     times = n_benchmarks )  # Close the backend. context$stop()  # Print the duration. print(duration_parabar, unit = \"ms\") #> Unit: milliseconds #>     expr      min       lq     mean   median       uq      max neval #>  parabar 71.75348 77.14632 85.72571 82.25771 91.12404 166.9339   100"},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"pbapply-execution-time","dir":"Articles","previous_headings":"Overhead","what":"pbapply execution time","title":"Comparison with other approaches","text":"repeat, , setup , time using pbapply package via ?pbapply::pbsapply function. Just like parabar, pbapply disables progress tracking non-interactive R sessions. Therefore, first need force progress tracking, , , avoid printing issues, redirect progress bar output /dev/null. results indicate running task function parallel via pbapply, progress tracking, average execution time M=143.4M = 143.4 milliseconds, SD=8.14SD = 8.14. Based results, overhead pbapply relative parallel roughly 128.26128.26 milliseconds.","code":"# Get original `pbapply` options. pbapply_options <- getOption(\"pboptions\")  # Get `knitr` progress option. knitr_option <- getOption(\"knitr.in.progress\")  # Create a copy of the `pbapply` options. pbapply_options_copy <- pbapply_options  # Create a copy of the `knitr` progress option. knitr_option_copy <- knitr_option  # Adjust the `pbapply` options to set a progress bar type. pbapply_options_copy$type <- \"timer\"  # Adjust the `knitr` option to indicate no knitting. knitr_option_copy <- NULL  # Set the adjusted options. options(pboptions = pbapply_options_copy) options(knitr.in.progress = knitr_option_copy)  # Check whether `pbapply` will use a progress bar. dopb() #> [1] TRUE # Create a cluster of five nodes. cluster <- makeCluster(spec = 5, type = \"PSOCK\")  # Measure the execution time of the task function. duration_pbapply <- microbenchmark(     # The task to benchmark.     pbapply = {         # Redirect the output.         sink(\"/dev/null\")          # Run the task in parallel.         pbsapply(X = n_tasks, FUN = task, cl = cluster)          # Disable the output redirection.         sink()     },      # Benchmark repetitions.     times = n_benchmarks )  # Stop the cluster. stopCluster(cluster)  # Print the duration. print(duration_pbapply, unit = \"ms\") #> Unit: milliseconds #>     expr      min       lq     mean   median       uq      max neval #>  pbapply 134.8485 138.0448 143.4029 140.5481 144.2281 177.0565   100 # Restore the original `pbapply` options. options(pboptions = pbapply_options)  # Restore the original `knitr` option. options(knitr.in.progress = knitr_option)"},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"summary","dir":"Articles","previous_headings":"Overhead","what":"Summary","title":"Comparison with other approaches","text":"section, provide brief summary differences execution times parallelization approaches discussed . First, can test whether significant differences average execution time parabar pbapply. test statistic indicates statistically significant mean differences execution times parabar (.e., M=85.73M = 85.73, SD=13.21SD = 13.21) pbapply (.e., M=143.4M = 143.4, SD=8.14SD = 8.14) packages, t(164.72)=−37.16t(164.72) = -37.16, p<0.001p < 0.001. Now, can proceed display execution time different parallelization approaches discussed. start pre-processing step combines results data frame computes additional variables (e.g., execution time milliseconds). Finally, can plot box plots execution times corresponding different parallelization approaches discussed.","code":"# Extract duration in milliseconds for `parabar`. parabar_time_ms <- duration_parabar$time / 1e6  # Extract duration in milliseconds for `pbapply`. pbapply_time_ms <- duration_pbapply$time / 1e6  # Test for mean differences. test_result <- t.test(     x = parabar_time_ms,     y = pbapply_time_ms, )  # Print the test result. print(test_result) #> #>  Welch Two Sample t-test #> #> data:  parabar_time_ms and pbapply_time_ms #> t = -37.162, df = 164.72, p-value < 2.2e-16 #> alternative hypothesis: true difference in means is not equal to 0 #> 95 percent confidence interval: #>  -60.74168 -54.61273 #> sample estimates: #> mean of x mean of y #>  85.72571 143.40292 # Create data frame from duration objects. results <- rbind(     duration_parallel,     duration_parabar,     duration_pbapply )  # Create execution time column in milliseconds. results$time_ms <- results$time / 1e6  # Create column indicating progress tracking. results$progress <- factor(     ifelse(with(results, expr %in% c(\"parabar\", \"pbapply\")), \"yes\", \"no\") )  # Print the data frame. print(results) #> Unit: milliseconds #>      expr       min        lq      mean    median        uq       max neval #>  parallel  14.65648  14.84083  15.14253  14.96682  15.09481  24.25228   100 #>   parabar  71.75348  77.14632  85.72571  82.25771  91.12404 166.93388   100 #>   pbapply 134.84855 138.04483 143.40292 140.54812 144.22812 177.05649   100 # Plot the results. ggplot(data = results, aes(x = expr, y = time_ms)) +     geom_boxplot(         aes(fill = progress),         width = 0.6     ) +     scale_y_continuous(         breaks = round(seq(min(results$time_ms), max(results$time_ms), length.out = 10)),     ) +     labs(         title = \"Execution time of different parallelization approaches\",         x = \"Parallelization approach\",         y = \"Execution time in milliseconds\"     ) +     scale_fill_manual(         name = \"Progress tracking\",         values = c(\"#f9bcec\", \"#9aa9e3\")     ) +     theme_bw() +     theme(         plot.title = element_text(             face = \"bold\",             vjust = 0.5,             size = 13         ),         axis.title.x = element_text(             margin = margin(t = 10, r = 0, b = 0, l = 0),             size = 12         ),         axis.title.y = element_text(             margin = margin(t = 0, r = 10, b = 0, l = 0),             size = 12         ),         axis.text.x = element_text(             margin = margin(t = 5, r = 0, b = 0, l = 0),             size = 11,             vjust = 0.5,         ),         axis.text.y = element_text(             margin = margin(t = 0, r = 5, b = 0, l = 0),             size = 11         ),         legend.title = element_text(             size = 12         ),         legend.text = element_text(             size = 11         ),         panel.grid.minor = element_line(             linewidth = 0.1         ),         panel.grid.major = element_line(             linewidth = 0.1         )     )"},{"path":"http://parabar.mihaiconstantin.com/articles/comparison.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Comparison with other approaches","text":"article, discussed different approaches adding progress-tracking functionality parallelized R code, showed parabar package good alternative pbapply achieving . parabar package demonstrated better performance pbapply terms execution time (.e., number tasks run large enough relative number nodes cluster). Execution time aside, parabar also provides granular progress bars reflect actual progress task, rather progress parallelization process. Despite name, parabar just package adds progress bars parallelized R code. design, provides standardized way interacting built-parallel package. top , proposes extensible mechanism augment parallel package functions new functionality. key benefit allows one customize parallelization process many different ways, sending email parallelized task finished executing. Therefore, progress tracking functionality discussed article just one example possible parabar.","code":""},{"path":"http://parabar.mihaiconstantin.com/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mihai Constantin. Author, maintainer.","code":""},{"path":"http://parabar.mihaiconstantin.com/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Constantin M (2024). parabar: Progress Bar Parallel Tasks. R package version 1.2.1, https://parabar.mihaiconstantin.com.","code":"@Manual{,   title = {parabar: Progress Bar for Parallel Tasks},   author = {Mihai Constantin},   year = {2024},   note = {R package version 1.2.1},   url = {https://parabar.mihaiconstantin.com}, }"},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Progress Bar for Parallel Tasks","text":"can install parabar directly CRAN using following command: Alternatively, can also install latest development version GitHub via:","code":"# Install the package from `CRAN`. install.packages(\"parabar\")  # Load the package. library(parabar) # Install the package from `GitHub`. remotes::install_github(\"mihaiconstantin/parabar\")  # Load the package. library(parabar)"},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Progress Bar for Parallel Tasks","text":"can find examples use parabar R scripts, end-users, developers. examples assume already installed loaded package.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"users","dir":"","previous_headings":"Usage","what":"Users","title":"Progress Bar for Parallel Tasks","text":"general, usage parabar consists following steps: Start backend parallel processing. Execute task parallel. Stop backend. Optionally, can also configure progress bar backend created supports progress tracking, perform additional operations backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"synchronous-backend","dir":"","previous_headings":"Usage > Users","what":"Synchronous Backend","title":"Progress Bar for Parallel Tasks","text":"simplest, perhaps least interesting, way use parabar requesting synchronous backend. point notice following warning message: reason progress tracking works asynchronous backends, parabar enables progress tracking default load time. can disable option get rid warning message. can verify warning message gone running task , reusing backend created earlier. done backend, can stop free resources.","code":"# Start a synchronous backend. backend <- start_backend(cores = 4, cluster_type = \"psock\", backend_type = \"sync\")  # Run a task in parallel. results <- par_sapply(backend, 1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) Warning message: Progress tracking not supported for backend of type 'SyncBackend'. # Disable progress tracking. set_option(\"progress_track\", FALSE) # Run a task in parallel. results <- par_sapply(backend, 1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) # Stop the backend. stop_backend(backend)"},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"asynchronous-backend","dir":"","previous_headings":"Usage > Users","what":"Asynchronous Backend","title":"Progress Bar for Parallel Tasks","text":"interesting way use parabar requesting asynchronous backend. default backend type, highlights strengths package. First, let’s ensure progress tracking enabled (.e., disabled ). Now, can proceed creating backend running task. point, can see progress bar displayed, progress tracked. progress bar updated real-time, task execution, e.g.: can also configure progress bar. example, suppose want display actual progress bar. progress bar now look like : default, parabar uses progress package display progress bar. However, can easily swap another progress bar engine. example, suppose want use built-utils::txtProgressBar. Check ?configure_bar information possible ways configuring progress bar. can also disable progress bar asynchronous backends altogether, adjusting package options. can stop backend done.","code":"# Enable progress tracking. set_option(\"progress_track\", TRUE) # Start an asynchronous backend. backend <- start_backend(cores = 4, cluster_type = \"psock\", backend_type = \"async\")  # Run a task in parallel. results <- par_sapply(backend, 1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) > completed 928 out of 1000 tasks [ 93%] [ 3s] # Change the progress bar options. configure_bar(type = \"modern\", format = \"[:bar] :percent\")  # Run a task in parallel. results <- par_sapply(backend, 1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) [====================>-------------------------------------------------]  30% # Change to and adjust the style of the `basic` progress bar. configure_bar(type = \"basic\", style = 3)  # Run a task in parallel. results <- par_sapply(backend, 1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) # Disable progress tracking. set_option(\"progress_track\", FALSE)  # Run a task in parallel. results <- par_sapply(backend, 1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) # Stop the backend. stop_backend(backend)"},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"no-backend","dir":"","previous_headings":"Usage > Users","what":"No Backend","title":"Progress Bar for Parallel Tasks","text":"Finally, can also ?par_sapply function without backend, resort running task sequentially means utils::sapply.","code":"# Run the task sequentially using the `base::sapply`. results <- par_sapply(backend = NULL, 1:300, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 })"},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"additional-operations","dir":"","previous_headings":"Usage > Users","what":"Additional Operations","title":"Progress Bar for Parallel Tasks","text":"indicated , general workflow consists starting backend, executing task parallel, stopping backend. However, additional operations can performed backend (.e., see Developers section). table lists available operations can performed backend. Check documentation corresponding operation information examples.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"developers","dir":"","previous_headings":"Usage","what":"Developers","title":"Progress Bar for Parallel Tasks","text":"parabar provides rich API developers want use package projects. high-level perspective, package consists backends contexts backends employed executing tasks parallel.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"backends","dir":"","previous_headings":"Usage > Developers","what":"Backends","title":"Progress Bar for Parallel Tasks","text":"backend represents set operations, defined ?BackendService interface. Backends can synchronous (.e., ?SyncBackend) asynchronous (.e., ?AsyncBackend). former block execution current R session parallel task completed, latter return immediately task executed background R session. ?BackendService interface defines following operations: start: Start backend. stop: Stop backend. clear: Remove objects backend. peek: Show variables names available backend. export: Export variables given environment backend. evaluate: Evaluate arbitrary expression backend. sapply: Run task backend. lapply: Run task backend. apply: Run task backend. get_output: Get output task execution. Check documentation BackendService information method.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"contexts","dir":"","previous_headings":"Usage > Developers","what":"Contexts","title":"Progress Bar for Parallel Tasks","text":"context represents specific conditions backend object operates. default context class (.e., ?Context) simply forwards call corresponding backend method. However, complex context can augment operation forwarding call backend. One example complex context ?ProgressTrackingContext class. class extends regular ?Context class decorates, e.g., backend sapply operation log progress task execution display progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"main-classes","dir":"","previous_headings":"Usage > Developers","what":"Main Classes","title":"Progress Bar for Parallel Tasks","text":"following main classes provided parabar: BackendService: Interface backend operations. SyncBackend: Synchronous backend extending abstract Backend class implementing BackendService interface. AsyncBackend: Asynchronous backend extending abstract Backend class implementing BackendService interface. Specification: Backend specification used starting backend. BackendFactory: Factory creating Backend objects. Context: Default context executing backend operations without interference. ProgressTrackingContext: Context decorating sapply operation track display progress. ContextFactory: Factory creating Context objects. UserApiConsumer: Wrapper around developer API. Additionally, parabar also provides several classes creating updating different progress bars, namely: BasicBar: simple, robust, bar created via utils::txtProgressBar extending Bar abstract class. ModernBar: modern bar created via progress::progress_bar extending Bar abstract class. BarFactory: Factory creating Bar objects.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"examples","dir":"","previous_headings":"Usage > Developers","what":"Examples","title":"Progress Bar for Parallel Tasks","text":"example use package R6 class API. start creating ?Specification object instructing ?Backend object create cluster via built-function parallel::makeCluster. proceed obtaining asynchronous backend instance ?BackendFactory starting backend using ?Specification instance . Finally, can run task parallel calling, e.g., sapply method backend instance. point, task deployed background R session, caller process free things. Calling backend$get_output immediately backend$sapply call throw error, indicating task still running, .e.: can, however, block caller process wait task complete fetching results. can now introduce context concept decorate backend instance , example, track progress task. First, obtain ?Context instance ?ContextFactory. Furthermore, since using asynchronous backend, can request context facilitates progress-tracking. ?Context class (.e., ’s subclasses) implements ?BackendService interface, means can use execute backend operations. Since using ?ProgressTrackingContext context, also need register ?Bar instance context. First, let’s obtain ?Bar instance ?BarFactory. can now register bar instance context instance. may also configure bar, change appearance. instance, may good idea show progress bar right away. point, backend$sapply operation decorated progress tracking. Finally, can run task parallel enjoy progress bar using context instance. left fetch results stop backend.","code":"# Create a specification object. specification <- Specification$new() specification$set_cores(4) specification$set_type(\"psock\") # Create a backend factory. backend_factory <- BackendFactory$new()  # Get an asynchronous backend instance. backend <- backend_factory$get(\"async\")  # Start the backend. backend$start(specification) # Run a task in parallel. backend$sapply(1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) Error: A task is currently running. results <- backend$get_output(wait = TRUE) # Create a context factory. context_factory <- ContextFactory$new()  # Get a progress-tracking context. context <- context_factory$get(\"progress\")  # Register the backend with the context. context$set_backend(backend) # Create a bar factory. bar_factory <- BarFactory$new()  # Get a `modern` bar (i.e., via `progress::progress_bar`). bar <- bar_factory$get(\"modern\") # Register the `bar` with the `context`. context$set_bar(bar) # Configure the `bar`. context$configure_bar(     show_after = 0,     format = \" > completed :current out of :total tasks [:percent] [:elapsed]\" ) # Run a task in parallel with progress tracking. context$sapply(1:1000, function(x) {     # Sleep a bit.     Sys.sleep(0.01)      # Compute and return.     x + 1 }) # Get the results. results <- context$get_output()  # Stop the backend. context$stop()"},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"design","dir":"","previous_headings":"Usage > Developers","what":"Design","title":"Progress Bar for Parallel Tasks","text":"Check UML diagram quick overview package design.  Note. sake clarity, diagram displays sapply operation running tasks parallel. However, operations supported well (.e., see table section Additional Operations).","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Progress Bar for Parallel Tasks","text":"contributions welcome greatly appreciated. Please open pull request GitHub. report bugs, request new features, please open issue GitHub.","code":""},{"path":"http://parabar.mihaiconstantin.com/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Progress Bar for Parallel Tasks","text":"package source code repository licensed MIT license. documentation, vignettes, website materials Mihai Constantin licensed CC 4.0 .","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":null,"dir":"Reference","previous_headings":"","what":"AsyncBackend — AsyncBackend","title":"AsyncBackend — AsyncBackend","text":"concrete implementation abstract class Backend implements BackendService interface. backend executes tasks parallel asynchronously (.e., without blocking main R session) parallel::makeCluster() cluster created background R session.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"AsyncBackend — AsyncBackend","text":"parabar::BackendService -> parabar::Backend -> AsyncBackend","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"AsyncBackend — AsyncBackend","text":"task_state list logical values indicating state task execution. See TaskState class information statues determined. following statuses available: task_not_started: Indicates whether backend free. TRUE signifies task started backend free deploy. task_is_running: Indicates whether task currently running backend. task_is_completed: Indicates whether task finished executing. TRUE signifies output task fetched. Calling method get_option() move output background R session main R session. output fetched, backend free deploy another task. session_state list logical values indicating state background session managing cluster. See SessionState class information available statuses. following statuses available: session_is_starting: Indicates whether session starting. session_is_idle: Indicates whether session idle. session_is_busy: Indicates whether session busy. session busy task running output task fetched main R session. See task_state field. session_is_finished: Indicates whether session closed.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"AsyncBackend — AsyncBackend","text":"AsyncBackend$new() AsyncBackend$start() AsyncBackend$stop() AsyncBackend$clear() AsyncBackend$peek() AsyncBackend$export() AsyncBackend$evaluate() AsyncBackend$sapply() AsyncBackend$lapply() AsyncBackend$apply() AsyncBackend$get_output() AsyncBackend$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"AsyncBackend — AsyncBackend","text":"Create new AsyncBackend object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"object class AsyncBackend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-start-","dir":"Reference","previous_headings":"","what":"Method start()","title":"AsyncBackend — AsyncBackend","text":"Start backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$start(specification)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"specification object class Specification contains backend configuration.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns void. resulting backend must stored .cluster private field Backend abstract class, accessible concrete backend implementations via active binding cluster.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"AsyncBackend — AsyncBackend","text":"Stop backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-clear-","dir":"Reference","previous_headings":"","what":"Method clear()","title":"AsyncBackend — AsyncBackend","text":"Remove objects backend. function equivalent calling rm(list = ls(.names = TRUE)) node backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$clear()"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-peek-","dir":"Reference","previous_headings":"","what":"Method peek()","title":"AsyncBackend — AsyncBackend","text":"Inspect backend variables available .GlobalEnv.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$peek()"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns list character vectors, element corresponds node backend. character vectors contain names variables available .GlobalEnv node.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-export-","dir":"Reference","previous_headings":"","what":"Method export()","title":"AsyncBackend — AsyncBackend","text":"Export variables given environment backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$export(variables, environment)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"variables character vector variable names export. environment environment object export variables.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-evaluate-","dir":"Reference","previous_headings":"","what":"Method evaluate()","title":"AsyncBackend — AsyncBackend","text":"Evaluate arbitrary expression backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$evaluate(expression)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"expression unquoted expression evaluate backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns result expression evaluation.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-sapply-","dir":"Reference","previous_headings":"","what":"Method sapply()","title":"AsyncBackend — AsyncBackend","text":"Run task backend akin parallel::parSapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$sapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-lapply-","dir":"Reference","previous_headings":"","what":"Method lapply()","title":"AsyncBackend — AsyncBackend","text":"Run task backend akin parallel::parLapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$lapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"AsyncBackend — AsyncBackend","text":"Run task backend akin parallel::parApply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$apply(x, margin, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"x array pass fun function. margin numeric vector indicating dimensions x fun function applied . example, matrix, margin = 1 indicates applying fun rows-wise, margin = 2 indicates applying fun columns-wise, margin = c(1, 2) indicates applying fun element-wise. Named dimensions also possible depending x. See parallel::parApply() base::apply() details. fun function apply x according margin. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-get-output-","dir":"Reference","previous_headings":"","what":"Method get_output()","title":"AsyncBackend — AsyncBackend","text":"Get output task execution.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$get_output(wait = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"wait logical value indicating whether wait task finish executing fetching results. Defaults FALSE. See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"AsyncBackend — AsyncBackend","text":"method fetches output task execution calling sapply() method. returns output immediately removes backend. Subsequent calls method throw error additional tasks executed meantime. method called execution task. wait = TRUE, method block main process backend finishes executing task results available. wait = FALSE, method immediately attempt fetch results background R session, throw error task still running.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"AsyncBackend — AsyncBackend","text":"vector, matrix, list length x, containing results fun. output format differs based specific operation employed. Check documentation apply operations parallel::parallel information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"AsyncBackend — AsyncBackend","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"AsyncBackend — AsyncBackend","text":"","code":"AsyncBackend$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"AsyncBackend — AsyncBackend","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/AsyncBackend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"AsyncBackend — AsyncBackend","text":"","code":"# Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 2)  # Set the cluster type. specification$set_type(type = \"psock\")  # Create an asynchronous backend object. backend <- AsyncBackend$new()  # Start the cluster on the backend. backend$start(specification)  # Check if there is anything on the backend. backend$peek() #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the variable to the backend. backend$export(\"name\")  # Remove variable from current environment. rm(name)  # Run an expression on the backend, using the exported variable `name`. backend$evaluate({     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Run a task in parallel (i.e., approx. 2.5 seconds). backend$sapply(     x = 1:10,     fun = function(x) {         # Sleep a bit.         Sys.sleep(0.5)          # Compute something.         output <- x + 1          # Return the result.         return(output)     } )  # Right know the main process is free and the task is executing on a `psock` # cluster started in a background `R` session.  # Trying to get the output immediately will throw an error, indicating that the # task is still running. try(backend$get_output()) #> Error : A task is currently running.  # However, we can block the main process and wait for the task to complete # before fetching the results. backend$get_output(wait = TRUE) #>  [1]  2  3  4  5  6  7  8  9 10 11  # Clear the backend. backend$clear()  # Check that there is nothing on the cluster. backend$peek() #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Stop the backend. backend$stop()  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend — Backend","title":"Backend — Backend","text":"abstract class serves base class concrete backend implementations. defines common properties concrete backends require.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Backend — Backend","text":"class instantiated. needs extended concrete subclasses implement pure virtual methods. Instances concrete backend implementations can conveniently obtained using BackendFactory class.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Backend — Backend","text":"parabar::BackendService -> Backend","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Backend — Backend","text":"cluster cluster object used backend. SyncBackend objects, cluster object created parallel::makeCluster(). AsyncBackend objects, permanent R session created callr::r_session contains parallel::makeCluster() cluster object. supports_progress boolean value indicating whether backend implementation supports progress tracking. active boolean value indicating whether backend implementation active cluster.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Backend — Backend","text":"parabar::BackendService$apply() parabar::BackendService$clear() parabar::BackendService$evaluate() parabar::BackendService$export() parabar::BackendService$get_output() parabar::BackendService$lapply() parabar::BackendService$peek() parabar::BackendService$sapply() parabar::BackendService$start() parabar::BackendService$stop()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Backend — Backend","text":"Backend$new() Backend$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Backend — Backend","text":"Create new Backend object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend — Backend","text":"","code":"Backend$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Backend — Backend","text":"Instantiating class throw error.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Backend — Backend","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend — Backend","text":"","code":"Backend$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/Backend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Backend — Backend","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":null,"dir":"Reference","previous_headings":"","what":"BackendFactory — BackendFactory","title":"BackendFactory — BackendFactory","text":"class factory provides concrete implementations Backend abstract class.","code":""},{"path":[]},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"BackendFactory — BackendFactory","text":"BackendFactory$get() BackendFactory$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"method-get-","dir":"Reference","previous_headings":"","what":"Method get()","title":"BackendFactory — BackendFactory","text":"Obtain concrete implementation abstract Backend class specified type.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendFactory — BackendFactory","text":"","code":"BackendFactory$get(type)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendFactory — BackendFactory","text":"type character string specifying type Backend instantiate. Possible values \"sync\" \"async\". See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BackendFactory — BackendFactory","text":"type = \"sync\" SyncBackend instance created returned. type = \"async\" AsyncBackend instance provided instead.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendFactory — BackendFactory","text":"concrete implementation class Backend. throws error requested backend type supported.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"BackendFactory — BackendFactory","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendFactory — BackendFactory","text":"","code":"BackendFactory$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendFactory — BackendFactory","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendFactory.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BackendFactory — BackendFactory","text":"","code":"# Create a backend factory. backend_factory <- BackendFactory$new()  # Get a synchronous backend instance. backend <- backend_factory$get(\"sync\")  # Check the class of the backend instance. class(backend) #> [1] \"SyncBackend\"    \"Backend\"        \"BackendService\" \"R6\"              # Get an asynchronous backend instance. backend <- backend_factory$get(\"async\")  # Check the class of the backend instance. class(backend) #> [1] \"AsyncBackend\"   \"Backend\"        \"BackendService\" \"R6\""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":null,"dir":"Reference","previous_headings":"","what":"BackendService — BackendService","title":"BackendService — BackendService","text":"interface defines operations available Backend implementation. Backend implementations Context class must implement interface.","code":""},{"path":[]},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"BackendService — BackendService","text":"BackendService$new() BackendService$start() BackendService$stop() BackendService$clear() BackendService$peek() BackendService$export() BackendService$evaluate() BackendService$sapply() BackendService$lapply() BackendService$apply() BackendService$get_output() BackendService$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"BackendService — BackendService","text":"Create new BackendService object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"Instantiating class throw error.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-start-","dir":"Reference","previous_headings":"","what":"Method start()","title":"BackendService — BackendService","text":"Start backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$start(specification)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"specification object class Specification contains backend configuration.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns void. resulting backend must stored .cluster private field Backend abstract class, accessible concrete backend implementations via active binding cluster.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"BackendService — BackendService","text":"Stop backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-clear-","dir":"Reference","previous_headings":"","what":"Method clear()","title":"BackendService — BackendService","text":"Remove objects backend. function equivalent calling rm(list = ls(.names = TRUE)) node backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$clear()"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BackendService — BackendService","text":"method ran default backend started.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-peek-","dir":"Reference","previous_headings":"","what":"Method peek()","title":"BackendService — BackendService","text":"Inspect backend variables available .GlobalEnv.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$peek()"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns list character vectors, element corresponds node backend. character vectors contain names variables available .GlobalEnv node.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-export-","dir":"Reference","previous_headings":"","what":"Method export()","title":"BackendService — BackendService","text":"Export variables given environment backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$export(variables, environment)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"variables character vector variable names export. environment environment object export variables.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-evaluate-","dir":"Reference","previous_headings":"","what":"Method evaluate()","title":"BackendService — BackendService","text":"Evaluate arbitrary expression backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$evaluate(expression)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"expression unquoted expression evaluate backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns result expression evaluation.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-sapply-","dir":"Reference","previous_headings":"","what":"Method sapply()","title":"BackendService — BackendService","text":"Run task backend akin parallel::parSapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$sapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-lapply-","dir":"Reference","previous_headings":"","what":"Method lapply()","title":"BackendService — BackendService","text":"Run task backend akin parallel::parLapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$lapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"BackendService — BackendService","text":"Run task backend akin parallel::parApply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$apply(x, margin, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"x array pass fun function. margin numeric vector indicating dimensions x fun function applied . example, matrix, margin = 1 indicates applying fun rows-wise, margin = 2 indicates applying fun columns-wise, margin = c(1, 2) indicates applying fun element-wise. Named dimensions also possible depending x. See parallel::parApply() base::apply() details. fun function apply x according margin. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-get-output-","dir":"Reference","previous_headings":"","what":"Method get_output()","title":"BackendService — BackendService","text":"Get output task execution.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$get_output(...)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"... Additional optional arguments may used concrete implementations.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"BackendService — BackendService","text":"method fetches output task execution calling sapply() method. returns output immediately removes backend. Therefore, subsequent calls method advised. method called execution task.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendService — BackendService","text":"vector, matrix, list length x, containing results fun. output format differs based specific operation employed. Check documentation apply operations parallel::parallel information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"BackendService — BackendService","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendService — BackendService","text":"","code":"BackendService$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/BackendService.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendService — BackendService","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Bar — Bar","title":"Bar — Bar","text":"abstract class defines pure virtual methods concrete bar must implement.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bar — Bar","text":"class instantiated. needs extended concrete subclasses implement pure virtual methods. Instances concrete backend implementations can conveniently obtained using BarFactory class.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Bar — Bar","text":"engine bar engine.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Bar — Bar","text":"Bar$new() Bar$create() Bar$update() Bar$terminate() Bar$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Bar — Bar","text":"Create new Bar object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bar — Bar","text":"","code":"Bar$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Bar — Bar","text":"Instantiating class throw error.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"method-create-","dir":"Reference","previous_headings":"","what":"Method create()","title":"Bar — Bar","text":"Create progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Bar — Bar","text":"","code":"Bar$create(total, initial, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bar — Bar","text":"total total number times progress bar tick. initial starting point progress bar. ... Additional arguments bar creation. See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Bar — Bar","text":"optional ... named arguments depend specific concrete implementation (.e., BasicBar ModernBar).","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Bar — Bar","text":"method returns void. resulting bar stored private field .bar, accessible via active binding engine.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"method-update-","dir":"Reference","previous_headings":"","what":"Method update()","title":"Bar — Bar","text":"Update progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Bar — Bar","text":"","code":"Bar$update(current)"},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bar — Bar","text":"current position progress bar (e.g., 30 100), usually index loop.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"method-terminate-","dir":"Reference","previous_headings":"","what":"Method terminate()","title":"Bar — Bar","text":"Terminate progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Bar — Bar","text":"","code":"Bar$terminate()"},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Bar — Bar","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Bar — Bar","text":"","code":"Bar$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/Bar.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bar — Bar","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":null,"dir":"Reference","previous_headings":"","what":"BackendFactory — BarFactory","title":"BackendFactory — BarFactory","text":"class factory provides concrete implementations Bar abstract class.","code":""},{"path":[]},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"BackendFactory — BarFactory","text":"BarFactory$get() BarFactory$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"method-get-","dir":"Reference","previous_headings":"","what":"Method get()","title":"BackendFactory — BarFactory","text":"Obtain concrete implementation abstract Bar class specified type.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendFactory — BarFactory","text":"","code":"BarFactory$get(type)"},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendFactory — BarFactory","text":"type character string specifying type Bar instantiate. Possible values \"modern\" \"basic\". See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BackendFactory — BarFactory","text":"type = \"modern\" ModernBar instance created returned. type = \"basic\" BasicBar instance provided instead.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"BackendFactory — BarFactory","text":"concrete implementation class Bar. throws error requested bar type supported.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"BackendFactory — BarFactory","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"BackendFactory — BarFactory","text":"","code":"BarFactory$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"BackendFactory — BarFactory","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BarFactory.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BackendFactory — BarFactory","text":"","code":"# Create a bar factory. bar_factory <- BarFactory$new()  # Get a modern bar instance. bar <- bar_factory$get(\"modern\")  # Check the class of the bar instance. class(bar) #> [1] \"ModernBar\" \"Bar\"       \"R6\"         # Get a basic bar instance. bar <- bar_factory$get(\"basic\")  # Check the class of the bar instance. class(bar) #> [1] \"BasicBar\" \"Bar\"      \"R6\""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":null,"dir":"Reference","previous_headings":"","what":"BasicBar — BasicBar","title":"BasicBar — BasicBar","text":"concrete implementation abstract class Bar using utils::txtProgressBar() engine progress bar.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"BasicBar — BasicBar","text":"parabar::Bar -> BasicBar","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"BasicBar — BasicBar","text":"BasicBar$new() BasicBar$create() BasicBar$update() BasicBar$terminate() BasicBar$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"BasicBar — BasicBar","text":"Create new BasicBar object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BasicBar — BasicBar","text":"","code":"BasicBar$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"BasicBar — BasicBar","text":"object class BasicBar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"method-create-","dir":"Reference","previous_headings":"","what":"Method create()","title":"BasicBar — BasicBar","text":"Create progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"BasicBar — BasicBar","text":"","code":"BasicBar$create(total, initial, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BasicBar — BasicBar","text":"total total number times progress bar tick. initial starting point progress bar. ... Additional arguments bar creation passed utils::txtProgressBar().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"BasicBar — BasicBar","text":"method returns void. resulting bar stored private field .bar, accessible via active binding engine. private field active binding defined super class Bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"method-update-","dir":"Reference","previous_headings":"","what":"Method update()","title":"BasicBar — BasicBar","text":"Update progress bar calling utils::setTxtProgressBar().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"BasicBar — BasicBar","text":"","code":"BasicBar$update(current)"},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"BasicBar — BasicBar","text":"current position progress bar (e.g., 30 100), usually index loop.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"method-terminate-","dir":"Reference","previous_headings":"","what":"Method terminate()","title":"BasicBar — BasicBar","text":"Terminate progress bar calling base::close() private field .bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"BasicBar — BasicBar","text":"","code":"BasicBar$terminate()"},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"BasicBar — BasicBar","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"BasicBar — BasicBar","text":"","code":"BasicBar$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"BasicBar — BasicBar","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/BasicBar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BasicBar — BasicBar","text":"","code":"# Create a basic bar instance. bar <- BasicBar$new()  # Specify the number of ticks to be performed. total <- 100  # Create the progress bar. bar$create(total = total, initial = 0)  # Use the progress bar. for (i in 1:total) {     # Sleep a bit.     Sys.sleep(0.02)      # Update the progress bar.     bar$update(i) } #> ================================================================================  # Terminate the progress bar. bar$terminate() #>"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":null,"dir":"Reference","previous_headings":"","what":"Context — Context","title":"Context — Context","text":"class represents base context interacting Backend implementations via BackendService interface.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Context — Context","text":"class vanilla wrapper around Backend implementation. registers backend instance forwards BackendService methods calls backend instance. Subclasses can override BackendService methods decorate backend instance additional functionality (e.g., see ProgressTrackingContext class example).","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Context — Context","text":"parabar::BackendService -> Context","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Context — Context","text":"backend Backend object registered context.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Context — Context","text":"Context$new() Context$set_backend() Context$start() Context$stop() Context$clear() Context$peek() Context$export() Context$evaluate() Context$sapply() Context$lapply() Context$apply() Context$get_output() Context$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Context — Context","text":"Create new Context object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"object class Context.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-set-backend-","dir":"Reference","previous_headings":"","what":"Method set_backend()","title":"Context — Context","text":"Set backend instance used context.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$set_backend(backend)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"backend object class Backend implements BackendService interface.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-start-","dir":"Reference","previous_headings":"","what":"Method start()","title":"Context — Context","text":"Start backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$start(specification)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"specification object class Specification contains backend configuration.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns void. resulting backend must stored .cluster private field Backend abstract class, accessible concrete backend implementations via active binding cluster.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"Context — Context","text":"Stop backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-clear-","dir":"Reference","previous_headings":"","what":"Method clear()","title":"Context — Context","text":"Remove objects backend. function equivalent calling rm(list = ls(.names = TRUE)) node backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$clear()"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-peek-","dir":"Reference","previous_headings":"","what":"Method peek()","title":"Context — Context","text":"Inspect backend variables available .GlobalEnv.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$peek()"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns list character vectors, element corresponds node backend. character vectors contain names variables available .GlobalEnv node.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-export-","dir":"Reference","previous_headings":"","what":"Method export()","title":"Context — Context","text":"Export variables given environment backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$export(variables, environment)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"variables character vector variable names export. environment environment object export variables. Defaults parent frame.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-evaluate-","dir":"Reference","previous_headings":"","what":"Method evaluate()","title":"Context — Context","text":"Evaluate arbitrary expression backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$evaluate(expression)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"expression unquoted expression evaluate backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns result expression evaluation.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-sapply-","dir":"Reference","previous_headings":"","what":"Method sapply()","title":"Context — Context","text":"Run task backend akin parallel::parSapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$sapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-lapply-","dir":"Reference","previous_headings":"","what":"Method lapply()","title":"Context — Context","text":"Run task backend akin parallel::parLapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$lapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"Context — Context","text":"Run task backend akin parallel::parApply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$apply(x, margin, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"x array pass fun function. margin numeric vector indicating dimensions x fun function applied . example, matrix, margin = 1 indicates applying fun rows-wise, margin = 2 indicates applying fun columns-wise, margin = c(1, 2) indicates applying fun element-wise. Named dimensions also possible depending x. See parallel::parApply() base::apply() details. fun function apply x according margin. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-get-output-","dir":"Reference","previous_headings":"","what":"Method get_output()","title":"Context — Context","text":"Get output task execution.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$get_output(...)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"... Additional arguments pass backend registered context. useful backends require additional arguments fetch output (e.g., AsyncBackend$get_output(wait = TRUE)).","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Context — Context","text":"method fetches output task execution calling sapply() method. returns output immediately removes backend. Therefore, subsequent calls method advised. method called execution task.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"Context — Context","text":"vector, matrix, list length x, containing results fun. output format differs based specific operation employed. Check documentation apply operations parallel::parallel information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Context — Context","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Context — Context","text":"","code":"Context$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Context — Context","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Context.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Context — Context","text":"","code":"# Define a task to run in parallel. task <- function(x, y) {     # Sleep a bit.     Sys.sleep(0.25)      # Return the result of a computation.     return(x + y) }  # Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 2)  # Set the cluster type. specification$set_type(type = \"psock\")  # Create a backend factory. backend_factory <- BackendFactory$new()  # Get a synchronous backend instance. backend <- backend_factory$get(\"sync\")  # Create a base context object. context <- Context$new()  # Register the backend with the context. context$set_backend(backend)  # From now all, all backend operations are intercepted by the context.  # Start the backend. context$start(specification)  # Run a task in parallel (i.e., approx. 1.25 seconds). context$sapply(x = 1:10, fun = task, y = 10)  # Get the task output. context$get_output() #>  [1] 11 12 13 14 15 16 17 18 19 20  # Close the backend. context$stop()  # Get an asynchronous backend instance. backend <- backend_factory$get(\"async\")  # Register the backend with the same context object. context$set_backend(backend)  # Start the backend reusing the specification object. context$start(specification)  # Run a task in parallel (i.e., approx. 1.25 seconds). context$sapply(x = 1:10, fun = task, y = 10)  # Get the task output. backend$get_output(wait = TRUE) #>  [1] 11 12 13 14 15 16 17 18 19 20  # Close the backend. context$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":null,"dir":"Reference","previous_headings":"","what":"ContextFactory — ContextFactory","title":"ContextFactory — ContextFactory","text":"class factory provides instances Context class.","code":""},{"path":[]},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"ContextFactory — ContextFactory","text":"ContextFactory$get() ContextFactory$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"method-get-","dir":"Reference","previous_headings":"","what":"Method get()","title":"ContextFactory — ContextFactory","text":"Obtain instances Context class.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ContextFactory — ContextFactory","text":"","code":"ContextFactory$get(type)"},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ContextFactory — ContextFactory","text":"type character string specifying type Context instantiate. Possible values \"regular\" \"progress\". See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ContextFactory — ContextFactory","text":"type = \"regular\" Context instance created returned. type = \"progress\" ProgressTrackingContext instance provided instead.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"ContextFactory — ContextFactory","text":"object type Context. throws error requested context type supported.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"ContextFactory — ContextFactory","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"ContextFactory — ContextFactory","text":"","code":"ContextFactory$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"ContextFactory — ContextFactory","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ContextFactory.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ContextFactory — ContextFactory","text":"","code":"# Create a context factory. context_factory <- ContextFactory$new()  # Get a regular context instance. context <- context_factory$get(\"regular\")  # Check the class of the context instance. class(context) #> [1] \"Context\"        \"BackendService\" \"R6\"              # Get a progress context instance. context <- context_factory$get(\"progress\") class(context) #> [1] \"ProgressTrackingContext\" \"Context\"                 #> [3] \"BackendService\"          \"R6\""},{"path":"http://parabar.mihaiconstantin.com/reference/Exception.html","id":null,"dir":"Reference","previous_headings":"","what":"Package Exceptions — Exception","title":"Package Exceptions — Exception","text":"class contains static methods throwing exceptions informative messages.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Exception.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Package Exceptions — Exception","text":"Exception$abstract_class_not_instantiable(object) Exception instantiating abstract classes interfaces. Exception$method_not_implemented() Exception calling methods without implementation. Exception$feature_not_developed() Exception running things yet developed. Exception$not_enough_cores() Exception requesting cores available machine. Exception$cluster_active() Exception attempting start cluster another one active. Exception$cluster_not_active() Exception attempting stop cluster active. Exception$async_task_not_started() Exception reading results asynchronous task yet started. Exception$async_task_running() Exception reading results asynchronous task running. Exception$async_task_completed() Exception reading results completed asynchronous task unread results. Exception$async_task_error(error) Exception errors running asynchronous task. Exception$stop_busy_backend_not_allowed() Exception stopping busy backend without intent. Exception$temporary_file_creation_failed() Exception reading results asynchronous task running. Exception$type_not_assignable(actual, expected) Exception providing incorrect object types. Exception$unknown_package_option(option) Exception requesting unknown package options. Exception$primitive_as_task_not_allowed() Exception decorating primitive functions progress tracking. Exception$array_margins_not_compatible(actual, allowed) Exception using improper margins BackendService$apply operation.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Helper.html","id":null,"dir":"Reference","previous_headings":"","what":"Package Helpers — Helper","title":"Package Helpers — Helper","text":"class contains static helper methods.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Helper.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Package Helpers — Helper","text":"Helper$get_class_name(object) Helper getting class given object. Helper$is_of_class(object, class) Check object certain class. Helper$get_option(option) Get package option, corresponding default value. Helper$set_option(option, value) Set package option. Helper$check_object_type(object, expected_type) Check type given object. Helper$check_array_margins(margins, dimensions) Helper check array margins BackendService$apply operation.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/LOGO.html","id":null,"dir":"Reference","previous_headings":"","what":"The Package Logo — LOGO","title":"The Package Logo — LOGO","text":"logo generated make_logo() displayed package attach interactive R sessions.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/LOGO.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Package Logo — LOGO","text":"","code":"LOGO"},{"path":"http://parabar.mihaiconstantin.com/reference/LOGO.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The Package Logo — LOGO","text":"object class character containing ASCII logo.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/LOGO.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Package Logo — LOGO","text":"","code":"print(LOGO) #> . . . . . . . . . . . . . . . . . . . . . . . . . . . #> .                              _             v1.x.x . #> .                             | |                   . #> .   _ __    __ _  _ __   __ _ | |__    __ _  _ __   . #> .  | '_ \\  / _` || '__| / _` || '_ \\  / _` || '__|  . #> .  | |_) || (_| || |   | (_| || |_) || (_| || |     . #> .  | .__/  \\____||_|    \\____||____/  \\____||_|     . #> .  | |                                              . #> .  |_|                                              . #> .                                                   . #> . . . . . . . . . . . . . . . . . . . . . . . . . . . #> .                         .                         . #> .        https://parabar.mihaiconstantin.com        . #> .                         .                         . #> . . . . . . . . . . . . . . . . . . . . . . . . . . ."},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":null,"dir":"Reference","previous_headings":"","what":"ModernBar — ModernBar","title":"ModernBar — ModernBar","text":"concrete implementation abstract class Bar using progress::progress_bar engine progress bar.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"ModernBar — ModernBar","text":"parabar::Bar -> ModernBar","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"ModernBar — ModernBar","text":"ModernBar$new() ModernBar$create() ModernBar$update() ModernBar$terminate() ModernBar$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"ModernBar — ModernBar","text":"Create new ModernBar object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModernBar — ModernBar","text":"","code":"ModernBar$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"ModernBar — ModernBar","text":"object class ModernBar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"method-create-","dir":"Reference","previous_headings":"","what":"Method create()","title":"ModernBar — ModernBar","text":"Create progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"ModernBar — ModernBar","text":"","code":"ModernBar$create(total, initial, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModernBar — ModernBar","text":"total total number times progress bar tick. initial starting point progress bar. ... Additional arguments bar creation passed progress::progress_bar$new().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"ModernBar — ModernBar","text":"method returns void. resulting bar stored private field .bar, accessible via active binding engine. private field active binding defined super class Bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"method-update-","dir":"Reference","previous_headings":"","what":"Method update()","title":"ModernBar — ModernBar","text":"Update progress bar calling progress::progress_bar$update().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"ModernBar — ModernBar","text":"","code":"ModernBar$update(current)"},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModernBar — ModernBar","text":"current position progress bar (e.g., 30 100), usually index loop.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"method-terminate-","dir":"Reference","previous_headings":"","what":"Method terminate()","title":"ModernBar — ModernBar","text":"Terminate progress bar calling progress::progress_bar$terminate().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"ModernBar — ModernBar","text":"","code":"ModernBar$terminate()"},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"ModernBar — ModernBar","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"ModernBar — ModernBar","text":"","code":"ModernBar$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModernBar — ModernBar","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ModernBar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModernBar — ModernBar","text":"","code":"# Create a modern bar instance. bar <- ModernBar$new()  # Specify the number of ticks to be performed. total <- 100  # Create the progress bar. bar$create(total = total, initial = 0)  # Use the progress bar. for (i in 1:total) {     # Sleep a bit.     Sys.sleep(0.02)      # Update the progress bar.     bar$update(i) }  # Terminate the progress bar. bar$terminate()"},{"path":"http://parabar.mihaiconstantin.com/reference/Options.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for Package Options — Options","title":"Class for Package Options — Options","text":"class holds public fields represent package options used configure default behavior functionality parabar provides.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Options.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for Package Options — Options","text":"instance class automatically created stored session base::.Options load time. instance can accessed changed via getOption(\"parabar\"). Specific package options can retrieved using helper function get_option().","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Options.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Class for Package Options — Options","text":"progress_track logical value indicating whether progress tracking enabled (.e., TRUE) disabled  (.e., FALSE) globally compatible backends. default value TRUE. progress_timeout numeric value indicating timeout (.e., seconds) subsequent checks log file new progress records. default value 0.001. progress_wait numeric value indicating approximate duration (.e., seconds) wait progress bar updates checking task finished (.e., possibly error). default value 0.1. progress_bar_type character string indicating default bar type use compatible backends. Possible values \"modern\" (default) \"basic\". progress_bar_config list lists containing default bar configuration supported bar engine. Elements lists represent arguments corresponding bar engines. Currently, supported bar engines : modern: progress::progress_bar engine, following default configuration: show_after = 0 format = \"> completed :current :total tasks [:percent] [:elapsed]\" basic: utils::txtProgressBar engine, default configuration. stop_forceful logical value indicating whether allow stopping asynchronous backend forcefully (.e., TRUE), (.e., FALSE). stopping forcefully, backend terminated without waiting running tasks finish results read main R session. default value FALSE.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Options.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Class for Package Options — Options","text":"progress_log_path character string indicating path log file track execution progress running task. default value temporary file generated base::tempfile(). Calling active binding repeatedly yield different temporary file paths. Fixing path specific value possible setting active binding character string representing desired path. Setting active binding NULL reset default value (.e., yielding different temporary file paths).","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class for Package Options — Options","text":"","code":"# Set the default package options (i.e., automatically set at load time). set_default_options()  # First, get the options instance from the session options. parabar <- getOption(\"parabar\")  # Then, disable progress tracking. parabar$progress_track <- FALSE  # Check that the change was applied (i.e., `progress_track: FALSE`). getOption(\"parabar\") #> <Options> #>   Public: #>     progress_bar_config: list #>     progress_bar_type: modern #>     progress_log_path: active binding #>     progress_timeout: 0.001 #>     progress_track: FALSE #>     progress_wait: 0.1 #>     stop_forceful: FALSE #>   Private: #>     .progress_log_path: NULL  # To restore defaults, set the default options again. set_default_options()  # Check that the change was applied (i.e., `progress_track: TRUE`). getOption(\"parabar\") #> <Options> #>   Public: #>     progress_bar_config: list #>     progress_bar_type: modern #>     progress_log_path: active binding #>     progress_timeout: 0.001 #>     progress_track: TRUE #>     progress_wait: 0.1 #>     stop_forceful: FALSE #>   Private: #>     .progress_log_path: NULL  # We can also use the built-in helpers to get and set options more conveniently.  # Get the progress tracking option. get_option(\"progress_track\") #> [1] TRUE  # Set the progress tracking option to `FALSE`. set_option(\"progress_track\", FALSE)  # Check that the change was applied (i.e., `progress_track: FALSE`). get_option(\"progress_track\") #> [1] FALSE  # Get a temporary file for logging the progress. get_option(\"progress_log_path\") #> [1] \"/tmp/Rtmp6EI7Ns/parabar16997e802739\"  # Fix the logging file path. set_option(\"progress_log_path\", \"./progress.log\")  # Check that the logging path change was applied. get_option(\"progress_log_path\") #> [1] \"./progress.log\"  # Restore the logging path to the default behavior. set_option(\"progress_log_path\", NULL)  # Check that the logging path change was applied. get_option(\"progress_log_path\") #> [1] \"/tmp/Rtmp6EI7Ns/parabar1699485d5221\"  # Restore the defaults. set_default_options()"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":null,"dir":"Reference","previous_headings":"","what":"ProgressTrackingContext — ProgressTrackingContext","title":"ProgressTrackingContext — ProgressTrackingContext","text":"class represents progress tracking context interacting Backend implementations via BackendService interface.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ProgressTrackingContext — ProgressTrackingContext","text":"class extends base Context class overrides sapply parent method decorate backend instance additional functionality. Specifically, class creates temporary file log progress backend tasks, creates progress bar display progress backend tasks. progress bar updated backend task execution. timeout subsequent checks temporary log file controlled Options class defaults 0.001. value can adjusted via Options instance present session base::.Options list (.e., see set_option()). example, set timeout 0.1 can run set_option(\"progress_timeout\", 0.1). class good example extend base Context class decorate backend instance additional functionality.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"ProgressTrackingContext — ProgressTrackingContext","text":"parabar::BackendService -> parabar::Context -> ProgressTrackingContext","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"ProgressTrackingContext — ProgressTrackingContext","text":"bar Bar instance registered context.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"ProgressTrackingContext — ProgressTrackingContext","text":"parabar::Context$clear() parabar::Context$evaluate() parabar::Context$export() parabar::Context$get_output() parabar::Context$initialize() parabar::Context$peek() parabar::Context$start() parabar::Context$stop()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"ProgressTrackingContext — ProgressTrackingContext","text":"ProgressTrackingContext$set_backend() ProgressTrackingContext$set_bar() ProgressTrackingContext$configure_bar() ProgressTrackingContext$sapply() ProgressTrackingContext$lapply() ProgressTrackingContext$apply() ProgressTrackingContext$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"method-set-backend-","dir":"Reference","previous_headings":"","what":"Method set_backend()","title":"ProgressTrackingContext — ProgressTrackingContext","text":"Set backend instance used context.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"ProgressTrackingContext$set_backend(backend)"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProgressTrackingContext — ProgressTrackingContext","text":"backend object class Backend supports progress tracking implements BackendService interface.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"ProgressTrackingContext — ProgressTrackingContext","text":"method overrides parent method validate backend provided guarantee instance AsyncBackend class.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"method-set-bar-","dir":"Reference","previous_headings":"","what":"Method set_bar()","title":"ProgressTrackingContext — ProgressTrackingContext","text":"Set Bar instance used context.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"ProgressTrackingContext$set_bar(bar)"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProgressTrackingContext — ProgressTrackingContext","text":"bar object class Bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"method-configure-bar-","dir":"Reference","previous_headings":"","what":"Method configure_bar()","title":"ProgressTrackingContext — ProgressTrackingContext","text":"Configure Bar instance registered context.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"ProgressTrackingContext$configure_bar(...)"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProgressTrackingContext — ProgressTrackingContext","text":"... list named arguments passed create() method Bar instance. See documentation specific concrete bar details (e.g., ModernBar).","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"method-sapply-","dir":"Reference","previous_headings":"","what":"Method sapply()","title":"ProgressTrackingContext — ProgressTrackingContext","text":"Run task backend akin parallel::parSapply(), progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"ProgressTrackingContext$sapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProgressTrackingContext — ProgressTrackingContext","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"ProgressTrackingContext — ProgressTrackingContext","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"method-lapply-","dir":"Reference","previous_headings":"","what":"Method lapply()","title":"ProgressTrackingContext — ProgressTrackingContext","text":"Run task backend akin parallel::parLapply(), progress bar.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"ProgressTrackingContext$lapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProgressTrackingContext — ProgressTrackingContext","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"ProgressTrackingContext — ProgressTrackingContext","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"ProgressTrackingContext — ProgressTrackingContext","text":"Run task backend akin parallel::parApply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"ProgressTrackingContext$apply(x, margin, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProgressTrackingContext — ProgressTrackingContext","text":"x array pass fun function. margin numeric vector indicating dimensions x fun function applied . example, matrix, margin = 1 indicates applying fun rows-wise, margin = 2 indicates applying fun columns-wise, margin = c(1, 2) indicates applying fun element-wise. Named dimensions also possible depending x. See parallel::parApply() base::apply() details. fun function apply x according margin. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"ProgressTrackingContext — ProgressTrackingContext","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"ProgressTrackingContext — ProgressTrackingContext","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"ProgressTrackingContext$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProgressTrackingContext — ProgressTrackingContext","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/ProgressTrackingContext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProgressTrackingContext — ProgressTrackingContext","text":"","code":"# Define a task to run in parallel. task <- function(x, y) {     # Sleep a bit.     Sys.sleep(0.15)      # Return the result of a computation.     return(x + y) }  # Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 2)  # Set the cluster type. specification$set_type(type = \"psock\")  # Create a backend factory. backend_factory <- BackendFactory$new()  # Get a backend instance that does not support progress tracking. backend <- backend_factory$get(\"sync\")  # Create a progress tracking context object. context <- ProgressTrackingContext$new()  # Attempt to set the incompatible backend instance. try(context$set_backend(backend)) #> Error : Argument of type 'SyncBackend' is not assignable to parameter of type 'AsyncBackend'.  # Get a backend instance that does support progress tracking. backend <- backend_factory$get(\"async\")  # Register the backend with the context. context$set_backend(backend)  # From now all, all backend operations are intercepted by the context.  # Start the backend. context$start(specification)  # Create a bar factory. bar_factory <- BarFactory$new()  # Get a modern bar instance. bar <- bar_factory$get(\"modern\")  # Register the bar with the context. context$set_bar(bar)  # Configure the bar. context$configure_bar(     show_after = 0,     format = \" > completed :current out of :total tasks [:percent] [:elapsed]\" )  # Run a task in parallel (i.e., approx. 1.9 seconds). context$sapply(x = 1:25, fun = task, y = 10)  # Get the task output. backend$get_output(wait = TRUE) #>  [1] 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  # Change the bar type. bar <- bar_factory$get(\"basic\")  # Register the bar with the context. context$set_bar(bar)  # Remove the previous bar configuration. context$configure_bar()  # Run a task in parallel (i.e., approx. 1.9 seconds). context$sapply(x = 1:25, fun = task, y = 10) #> ================================================================================  # Get the task output. backend$get_output(wait = TRUE) #>  [1] 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  # Close the backend. context$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":null,"dir":"Reference","previous_headings":"","what":"SessionState — SessionState","title":"SessionState — SessionState","text":"class holds state background session used asynchronous backend (.e., AsyncBackend). See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SessionState — SessionState","text":"session state useful check asynchronous backend ready certain operations. session can one following four states time: session_is_starting: TRUE, indicates session starting. session_is_idle: TRUE, indicates session idle ready execute operations. session_is_busy: TRUE, indicates session busy (.e., see TaskState class information task's state). session_is_finished: TRUE, indicates session closed longer available operations.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"SessionState — SessionState","text":"session_is_starting logical value indicating whether session starting. session_is_idle logical value indicating whether session idle ready execute operations. session_is_busy logical value indicating whether session busy. session_is_finished logical value indicating whether session closed longer available operations.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"SessionState — SessionState","text":"SessionState$new() SessionState$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"SessionState — SessionState","text":"Create new SessionState object determine state given background session.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SessionState — SessionState","text":"","code":"SessionState$new(session)"},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SessionState — SessionState","text":"session callr::r_session object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"SessionState — SessionState","text":"object class SessionState.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"SessionState — SessionState","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"SessionState — SessionState","text":"","code":"SessionState$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"SessionState — SessionState","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SessionState.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SessionState — SessionState","text":"","code":"# Handy function to print the session states all at once. check_state <- function(session) {     # Create a session object and determine its state.     session_state <- SessionState$new(session)      # Print the state.     cat(         \"Session is starting: \", session_state$session_is_starting, \"\\n\",         \"Session is idle: \", session_state$session_is_idle, \"\\n\",         \"Session is busy: \", session_state$session_is_busy, \"\\n\",         \"Session is finished: \", session_state$session_is_finished, \"\\n\",         sep = \"\"     ) }  # Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 2)  # Set the cluster type. specification$set_type(type = \"psock\")  # Create an asynchronous backend object. backend <- AsyncBackend$new()  # Start the cluster on the backend. backend$start(specification)  # Check that the session is idle. check_state(backend$cluster) #> Session is starting: FALSE #> Session is idle: TRUE #> Session is busy: FALSE #> Session is finished: FALSE  {     # Run a task in parallel (i.e., approx. 0.25 seconds).     backend$sapply(         x = 1:10,         fun = function(x) {             # Sleep a bit.             Sys.sleep(0.05)              # Compute something.             output <- x + 1              # Return the result.             return(output)         }     )      # And immediately check that the session is busy.     check_state(backend$cluster) } #> Session is starting: FALSE #> Session is idle: FALSE #> Session is busy: TRUE #> Session is finished: FALSE  # Get the output and wait for the task to complete. output <- backend$get_output(wait = TRUE)  # Check that the session is idle again. check_state(backend$cluster) #> Session is starting: FALSE #> Session is idle: TRUE #> Session is busy: FALSE #> Session is finished: FALSE  # Manually close the session. backend$cluster$close()  # Check that the session is finished. check_state(backend$cluster) #> Session is starting: FALSE #> Session is idle: FALSE #> Session is busy: FALSE #> Session is finished: TRUE  # Stop the backend. backend$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":null,"dir":"Reference","previous_headings":"","what":"Specification — Specification","title":"Specification — Specification","text":"class contains information required start backend. instance class used start method BackendService interface.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Specification — Specification","text":"cores number nodes use cluster creation. type type cluster create. types supported cluster types.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Specification — Specification","text":"Specification$set_cores() Specification$set_type() Specification$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"method-set-cores-","dir":"Reference","previous_headings":"","what":"Method set_cores()","title":"Specification — Specification","text":"Set number nodes use cluster.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specification — Specification","text":"","code":"Specification$set_cores(cores)"},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specification — Specification","text":"cores number nodes use cluster.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specification — Specification","text":"method also performs validation requested number cores, ensuring value lies 2 parallel::detectCores() - 1.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"method-set-type-","dir":"Reference","previous_headings":"","what":"Method set_type()","title":"Specification — Specification","text":"Set type cluster create.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Specification — Specification","text":"","code":"Specification$set_type(type)"},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specification — Specification","text":"type type cluster create. Possible values \"fork\" \"psock\". Defaults \"psock\".","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Specification — Specification","text":"type explicitly requested (.e., type = NULL), type determined based operating system. Unix-like systems, type set \"fork\", Windows systems, type set \"psock\". unknown type requested, warning issued type set \"psock\".","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Specification — Specification","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Specification — Specification","text":"","code":"Specification$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specification — Specification","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Specification.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specification — Specification","text":"","code":"# Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 4) #> Warning: Argument `cores` cannot be larger than 3. Setting to 3.  # Set the cluster type. specification$set_type(type = \"psock\")  # Get the number of cores. specification$cores #> [1] 3  # Get the cluster type. specification$type #> [1] \"PSOCK\"  # Attempt to set too many cores. specification$set_cores(cores = 100) #> Warning: Argument `cores` cannot be larger than 3. Setting to 3.  # Check that the cores were reasonably set. specification$cores #> [1] 3  # Allow the object to determine the adequate cluster type. specification$set_type(type = NULL)  # Check the type determined. specification$type #>   unix  #> \"FORK\"   # Attempt to set an invalid cluster type. specification$set_type(type = \"invalid\") #> Warning: Argument `type` must be 'fork' or 'psock'. Defaulting to 'psock'.  # Check that the type was set to `psock`. specification$type #> windows  #> \"PSOCK\""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":null,"dir":"Reference","previous_headings":"","what":"SyncBackend — SyncBackend","title":"SyncBackend — SyncBackend","text":"concrete implementation abstract class Backend implements BackendService interface. backend executes tasks parallel parallel::makeCluster() cluster synchronously (.e., blocking main R session).","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"SyncBackend — SyncBackend","text":"parabar::BackendService -> parabar::Backend -> SyncBackend","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"SyncBackend — SyncBackend","text":"SyncBackend$new() SyncBackend$start() SyncBackend$stop() SyncBackend$clear() SyncBackend$peek() SyncBackend$export() SyncBackend$evaluate() SyncBackend$sapply() SyncBackend$lapply() SyncBackend$apply() SyncBackend$get_output() SyncBackend$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"SyncBackend — SyncBackend","text":"Create new SyncBackend object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$new()"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"object class SyncBackend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-start-","dir":"Reference","previous_headings":"","what":"Method start()","title":"SyncBackend — SyncBackend","text":"Start backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$start(specification)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"specification object class Specification contains backend configuration.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns void. resulting backend must stored .cluster private field Backend abstract class, accessible concrete backend implementations via active binding cluster.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"SyncBackend — SyncBackend","text":"Stop backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-clear-","dir":"Reference","previous_headings":"","what":"Method clear()","title":"SyncBackend — SyncBackend","text":"Remove objects backend. function equivalent calling rm(list = ls(.names = TRUE)) node backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$clear()"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-peek-","dir":"Reference","previous_headings":"","what":"Method peek()","title":"SyncBackend — SyncBackend","text":"Inspect backend variables available .GlobalEnv.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$peek()"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns list character vectors, element corresponds node backend. character vectors contain names variables available .GlobalEnv node.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-export-","dir":"Reference","previous_headings":"","what":"Method export()","title":"SyncBackend — SyncBackend","text":"Export variables given environment backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$export(variables, environment)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"variables character vector variable names export. environment environment object export variables. Defaults parent frame.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns void.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-evaluate-","dir":"Reference","previous_headings":"","what":"Method evaluate()","title":"SyncBackend — SyncBackend","text":"Evaluate arbitrary expression backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$evaluate(expression)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"expression unquoted expression evaluate backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns result expression evaluation.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-sapply-","dir":"Reference","previous_headings":"","what":"Method sapply()","title":"SyncBackend — SyncBackend","text":"Run task backend akin parallel::parSapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$sapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-lapply-","dir":"Reference","previous_headings":"","what":"Method lapply()","title":"SyncBackend — SyncBackend","text":"Run task backend akin parallel::parLapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$lapply(x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"SyncBackend — SyncBackend","text":"Run task backend akin parallel::parApply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$apply(x, margin, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"x array pass fun function. margin numeric vector indicating dimensions x fun function applied . example, matrix, margin = 1 indicates applying fun rows-wise, margin = 2 indicates applying fun columns-wise, margin = c(1, 2) indicates applying fun element-wise. Named dimensions also possible depending x. See parallel::parApply() base::apply() details. fun function apply x according margin. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"method returns void. output task execution must stored private field .output Backend abstract class, accessible via get_output() method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-get-output-","dir":"Reference","previous_headings":"","what":"Method get_output()","title":"SyncBackend — SyncBackend","text":"Get output task execution.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$get_output(...)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"... Additional arguments currently use.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SyncBackend — SyncBackend","text":"method fetches output task execution calling sapply() method. returns output immediately removes backend. Therefore, subsequent calls method return NULL. method called execution task.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"SyncBackend — SyncBackend","text":"vector, matrix, list length x, containing results fun. output format differs based specific operation employed. Check documentation apply operations parallel::parallel information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"SyncBackend — SyncBackend","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"SyncBackend — SyncBackend","text":"","code":"SyncBackend$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"SyncBackend — SyncBackend","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/SyncBackend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SyncBackend — SyncBackend","text":"","code":"# Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 2)  # Set the cluster type. specification$set_type(type = \"psock\")  # Create a synchronous backend object. backend <- SyncBackend$new()  # Start the cluster on the backend. backend$start(specification)  # Check if there is anything on the backend. backend$peek() #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the variable from the current environment to the backend. backend$export(\"name\", environment())  # Remove variable from current environment. rm(name)  # Run an expression on the backend, using the exported variable `name`. backend$evaluate({     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Run a task in parallel (i.e., approx. 1.25 seconds). backend$sapply(     x = 1:10,     fun = function(x) {         # Sleep a bit.         Sys.sleep(0.25)          # Compute something.         output <- x + 1          # Return the result.         return(output)     } )  # Get the task output. backend$get_output() #>  [1]  2  3  4  5  6  7  8  9 10 11  # Clear the backend. backend$clear()  # Check that there is nothing on the cluster. backend$peek() #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Stop the backend. backend$stop()  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":null,"dir":"Reference","previous_headings":"","what":"TaskState — TaskState","title":"TaskState — TaskState","text":"class holds state task deployed asynchronous backend (.e., AsyncBackend). See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"TaskState — TaskState","text":"task state useful check asynchronous backend free execute operations. task can one following three states time: task_not_started: TRUE, indicates whether backend free execute another operation. task_is_running: TRUE, indicates task running backend. task_is_completed: TRUE, indicates task completed, backend still busy task output retrieved. task state determined based state background session (.e., see get_state method callr::r_session) state task execution inferred polling process (.e., see poll_process method callr::r_session) follows:","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"TaskState — TaskState","text":"task_not_started logical value indicating whether task started. used determine backend free execute another operation. task_is_running logical value indicating whether task running. task_is_completed logical value indicating whether task completed output needs retrieved.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"TaskState — TaskState","text":"TaskState$new() TaskState$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"TaskState — TaskState","text":"Create new TaskState object determine state task given background session.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TaskState — TaskState","text":"","code":"TaskState$new(session)"},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TaskState — TaskState","text":"session callr::r_session object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"TaskState — TaskState","text":"object class TaskState.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"TaskState — TaskState","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"TaskState — TaskState","text":"","code":"TaskState$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"TaskState — TaskState","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/TaskState.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TaskState — TaskState","text":"","code":"# Handy function to print the task states all at once. check_state <- function(session) {     # Create a task state object and determine the state.     task_state <- TaskState$new(session)      # Print the state.     cat(         \"Task not started: \", task_state$task_not_started, \"\\n\",         \"Task is running: \", task_state$task_is_running, \"\\n\",         \"Task is completed: \", task_state$task_is_completed, \"\\n\",         sep = \"\"     ) }  # Create a specification object. specification <- Specification$new()  # Set the number of cores. specification$set_cores(cores = 2)  # Set the cluster type. specification$set_type(type = \"psock\")  # Create an asynchronous backend object. backend <- AsyncBackend$new()  # Start the cluster on the backend. backend$start(specification)  # Check that the task has not been started (i.e., the backend is free). check_state(backend$cluster) #> Task not started: TRUE #> Task is running: FALSE #> Task is completed: FALSE  {     # Run a task in parallel (i.e., approx. 0.25 seconds).     backend$sapply(         x = 1:10,         fun = function(x) {             # Sleep a bit.             Sys.sleep(0.05)              # Compute something.             output <- x + 1              # Return the result.             return(output)         }     )      # And immediately check the state to see that the task is running.     check_state(backend$cluster) } #> Task not started: FALSE #> Task is running: TRUE #> Task is completed: FALSE  # Sleep for a bit to wait for the task to complete. Sys.sleep(1)  # Check that the task is completed (i.e., the output needs to be retrieved). check_state(backend$cluster) #> Task not started: FALSE #> Task is running: TRUE #> Task is completed: FALSE  # Get the output. output <- backend$get_output(wait = TRUE)  # Check that the task has not been started (i.e., the backend is free again). check_state(backend$cluster) #> Task not started: TRUE #> Task is running: FALSE #> Task is completed: FALSE  # Stop the backend. backend$stop()"},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":null,"dir":"Reference","previous_headings":"","what":"UserApiConsumer — UserApiConsumer","title":"UserApiConsumer — UserApiConsumer","text":"class opinionated interface around developer API parabar package. See Details section information class works.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"UserApiConsumer — UserApiConsumer","text":"class acts wrapper around R6::R6 developer API parabar package. nutshell, provides opinionated interface wrapping developer API simple functional calls. specifically, executing task parallel, class performs following steps: Validates backend provided. Instantiates appropriate parabar context based backend. backend supports progress tracking (.e., backend instance AsyncBackend), progress tracking context (.e., ProgressTrackingContext) instantiated used. Otherwise, regular context (.e., Context) instantiated. regular context also used progress tracking disabled via Options instance. Registers backend context. Instantiates configures progress bar based Options instance session base::.Options list. Executes task parallel, displays progress bar appropriate. Fetches results backend returns .","code":""},{"path":[]},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"UserApiConsumer — UserApiConsumer","text":"UserApiConsumer$sapply() UserApiConsumer$lapply() UserApiConsumer$apply() UserApiConsumer$clone()","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"method-sapply-","dir":"Reference","previous_headings":"","what":"Method sapply()","title":"UserApiConsumer — UserApiConsumer","text":"Execute task parallel akin parallel::parSapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UserApiConsumer — UserApiConsumer","text":"","code":"UserApiConsumer$sapply(backend, x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UserApiConsumer — UserApiConsumer","text":"backend object class Backend returned start_backend() function. can also NULL run task sequentially via base::sapply(). x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"UserApiConsumer — UserApiConsumer","text":"vector length x containing results fun. output format resembles base::sapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"method-lapply-","dir":"Reference","previous_headings":"","what":"Method lapply()","title":"UserApiConsumer — UserApiConsumer","text":"Execute task parallel akin parallel::parLapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"UserApiConsumer — UserApiConsumer","text":"","code":"UserApiConsumer$lapply(backend, x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"UserApiConsumer — UserApiConsumer","text":"backend object class Backend returned start_backend() function. can also NULL run task sequentially via base::lapply(). x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"UserApiConsumer — UserApiConsumer","text":"list length x containing results fun. output format resembles base::lapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"UserApiConsumer — UserApiConsumer","text":"Execute task parallel akin parallel::parApply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"UserApiConsumer — UserApiConsumer","text":"","code":"UserApiConsumer$apply(backend, x, margin, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"UserApiConsumer — UserApiConsumer","text":"backend object class Backend returned start_backend() function. can also NULL run task sequentially via base::apply(). x array pass fun function. margin numeric vector indicating dimensions x fun function applied . example, matrix, margin = 1 indicates applying fun rows-wise, margin = 2 indicates applying fun columns-wise, margin = c(1, 2) indicates applying fun element-wise. Named dimensions also possible depending x. See parallel::parApply() base::apply() details. fun function apply x according margin. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"UserApiConsumer — UserApiConsumer","text":"dimensions output vary according margin argument. Consult documentation base::apply() detailed explanation output structured.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"UserApiConsumer — UserApiConsumer","text":"objects class cloneable method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"UserApiConsumer — UserApiConsumer","text":"","code":"UserApiConsumer$clone(deep = FALSE)"},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"UserApiConsumer — UserApiConsumer","text":"deep Whether make deep clone.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/UserApiConsumer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"UserApiConsumer — UserApiConsumer","text":"","code":"# Define a simple task. task <- function(x) {     # Perform computations.     Sys.sleep(0.01)      # Return the result.     return(x + 1) }  # Start an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Change the progress bar options. configure_bar(type = \"modern\", format = \"[:bar] :percent\")  # Create an user API consumer. consumer <- UserApiConsumer$new()  # Execute the task using the `sapply` parallel operation. output_sapply <- consumer$sapply(backend = backend, x = 1:200, fun = task)  # Print the head of the `sapply` operation output. head(output_sapply) #> [1] 2 3 4 5 6 7  # Execute the task using the `sapply` parallel operation. output_lapply <- consumer$lapply(backend = backend, x = 1:200, fun = task)  # Print the head of the `lapply` operation output. head(output_lapply) #> [[1]] #> [1] 2 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 4 #>  #> [[4]] #> [1] 5 #>  #> [[5]] #> [1] 6 #>  #> [[6]] #> [1] 7 #>   # Stop the backend. stop_backend(backend)"},{"path":"http://parabar.mihaiconstantin.com/reference/Warning.html","id":null,"dir":"Reference","previous_headings":"","what":"Package Warnings — Warning","title":"Package Warnings — Warning","text":"class contains static methods throwing warnings informative messages.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/Warning.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Package Warnings — Warning","text":"Warning$requested_cluster_cores_too_low() Warning requesting enough cluster cores. Warning$requested_cluster_cores_too_high() Warning requesting many cluster cores. Warning$requested_cluster_type_not_supported() Warning requesting unsupported cluster type. Warning$progress_not_supported_for_backend() Warning using backend incompatible progress tracking. Warning$error_in_backend_finalizer() Warning errors backend finalizer garbage collection.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/clear.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear a Backend — clear","title":"Clear a Backend — clear","text":"function can used clear backend created start_backend().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/clear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear a Backend — clear","text":"","code":"clear(backend)"},{"path":"http://parabar.mihaiconstantin.com/reference/clear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear a Backend — clear","text":"backend object class Backend returned start_backend() function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/clear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear a Backend — clear","text":"function returns void. throws error value provided backend argument instance class Backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/clear.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clear a Backend — clear","text":"function convenience wrapper around lower-lever API parabar aimed developers. specifically, function calls clear method provided backend instance.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/clear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clear a Backend — clear","text":"","code":"# Create an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Check that the backend is active. backend$active #> [1] TRUE  # Check if there is anything on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the `name` variable in the current environment to the backend. export(backend, \"name\", environment())  # Remove the dummy variable from the current environment. rm(name)  # Check the backend to see that the variable has been exported. peek(backend) #> [[1]] #> [1] \"name\" #>  #> [[2]] #> [1] \"name\" #>   # Run an expression on the backend. # Note that the symbols in the expression are resolved on the backend. evaluate(backend, {     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Clear the backend. clear(backend)  # Check that there is nothing on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Use a basic progress bar (i.e., see `parabar::Bar`). configure_bar(type = \"basic\", style = 3)  # Run a task in parallel (i.e., approx. 1.25 seconds). output <- par_sapply(backend, x = 1:10, fun = function(x) {     # Sleep a bit.     Sys.sleep(0.25)      # Compute and return.     return(x + 1) })  # Print the output. print(output) #>  [1]  2  3  4  5  6  7  8  9 10 11  # Stop the backend. stop_backend(backend)  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/reference/configure_bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure The Progress Bar — configure_bar","title":"Configure The Progress Bar — configure_bar","text":"function can used conveniently configure progress bar adjusting progress_bar_config field Options instance base::.Options list.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/configure_bar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure The Progress Bar — configure_bar","text":"","code":"configure_bar(type = \"modern\", ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/configure_bar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure The Progress Bar — configure_bar","text":"type character string specifying type progress bar used compatible backends. Possible values \"modern\" \"basic\". default value \"modern\". ... list named arguments used configure progress bar. See Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/configure_bar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure The Progress Bar — configure_bar","text":"function returns void. throws error requested bar type supported.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/configure_bar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Configure The Progress Bar — configure_bar","text":"optional ... named arguments depend type progress bar configured. type = \"modern\", ... take named arguments progress::progress_bar class. type = \"basic\", ... take named arguments utils::txtProgressBar() built-function. See Examples section demonstration.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/configure_bar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Configure The Progress Bar — configure_bar","text":"","code":"# Set the default package options. set_default_options()  # Get the progress bar type from options. get_option(\"progress_bar_type\") #> [1] \"modern\"  # Get the progress bar configuration from options. get_option(\"progress_bar_config\") #> $modern #> $modern$show_after #> [1] 0 #>  #> $modern$format #> [1] \" > completed :current out of :total tasks [:percent] [:elapsed]\" #>  #>  #> $basic #> list() #>   # Adjust the format of the `modern` progress bar. configure_bar(type = \"modern\", format = \"[:bar] :percent\")  # Check that the configuration has been updated in the options. get_option(\"progress_bar_config\") #> $modern #> $modern$show_after #> [1] 0 #>  #> $modern$format #> [1] \"[:bar] :percent\" #>  #>  #> $basic #> list() #>   # Change to and adjust the style of the `basic` progress bar. configure_bar(type = \"basic\", style = 3)  # Check that the configuration has been updated in the options. get_option(\"progress_bar_type\") #> [1] \"basic\" get_option(\"progress_bar_config\") #> $modern #> $modern$show_after #> [1] 0 #>  #> $modern$format #> [1] \"[:bar] :percent\" #>  #>  #> $basic #> $basic$style #> [1] 3 #>  #>"},{"path":"http://parabar.mihaiconstantin.com/reference/evaluate.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate An Expression On The Backend — evaluate","title":"Evaluate An Expression On The Backend — evaluate","text":"function can used evaluate arbitrary base::expression() backend created start_backend().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/evaluate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate An Expression On The Backend — evaluate","text":"","code":"evaluate(backend, expression)"},{"path":"http://parabar.mihaiconstantin.com/reference/evaluate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate An Expression On The Backend — evaluate","text":"backend object class Backend returned start_backend() function. expression unquoted expression evaluate backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/evaluate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate An Expression On The Backend — evaluate","text":"method returns result expression evaluation. throws error value provided backend argument instance class Backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/evaluate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate An Expression On The Backend — evaluate","text":"function convenience wrapper around lower-lever API parabar aimed developers. specifically, function calls evaluate method provided backend instance.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/evaluate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate An Expression On The Backend — evaluate","text":"","code":"# Create an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Check that the backend is active. backend$active #> [1] TRUE  # Check if there is anything on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the `name` variable in the current environment to the backend. export(backend, \"name\", environment())  # Remove the dummy variable from the current environment. rm(name)  # Check the backend to see that the variable has been exported. peek(backend) #> [[1]] #> [1] \"name\" #>  #> [[2]] #> [1] \"name\" #>   # Run an expression on the backend. # Note that the symbols in the expression are resolved on the backend. evaluate(backend, {     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Clear the backend. clear(backend)  # Check that there is nothing on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Use a basic progress bar (i.e., see `parabar::Bar`). configure_bar(type = \"basic\", style = 3)  # Run a task in parallel (i.e., approx. 1.25 seconds). output <- par_sapply(backend, x = 1:10, fun = function(x) {     # Sleep a bit.     Sys.sleep(0.25)      # Compute and return.     return(x + 1) })  # Print the output. print(output) #>  [1]  2  3  4  5  6  7  8  9 10 11  # Stop the backend. stop_backend(backend)  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/reference/export.html","id":null,"dir":"Reference","previous_headings":"","what":"Export Objects To a Backend — export","title":"Export Objects To a Backend — export","text":"function can used export objects backend created start_backend().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/export.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export Objects To a Backend — export","text":"","code":"export(backend, variables, environment)"},{"path":"http://parabar.mihaiconstantin.com/reference/export.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export Objects To a Backend — export","text":"backend object class Backend returned start_backend() function. variables character vector variable names export backend. environment environment export variables. environment provided, .GlobalEnv environment used.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/export.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export Objects To a Backend — export","text":"function returns void. throws error value provided backend argument instance class Backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/export.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export Objects To a Backend — export","text":"function convenience wrapper around lower-lever API parabar aimed developers. specifically, function calls export method provided backend instance.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/export.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export Objects To a Backend — export","text":"","code":"# Create an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Check that the backend is active. backend$active #> [1] TRUE  # Check if there is anything on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the `name` variable in the current environment to the backend. export(backend, \"name\", environment())  # Remove the dummy variable from the current environment. rm(name)  # Check the backend to see that the variable has been exported. peek(backend) #> [[1]] #> [1] \"name\" #>  #> [[2]] #> [1] \"name\" #>   # Run an expression on the backend. # Note that the symbols in the expression are resolved on the backend. evaluate(backend, {     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Clear the backend. clear(backend)  # Check that there is nothing on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Use a basic progress bar (i.e., see `parabar::Bar`). configure_bar(type = \"basic\", style = 3)  # Run a task in parallel (i.e., approx. 1.25 seconds). output <- par_sapply(backend, x = 1:10, fun = function(x) {     # Sleep a bit.     Sys.sleep(0.25)      # Compute and return.     return(x + 1) })  # Print the output. print(output) #>  [1]  2  3  4  5  6  7  8  9 10 11  # Stop the backend. stop_backend(backend)  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/reference/make_logo.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Package Logo — make_logo","title":"Generate Package Logo — make_logo","text":"function meant generating updating logo. running procedure end stored LOGO constant.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/make_logo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Package Logo — make_logo","text":"","code":"make_logo(   template = \"./inst/assets/logo/parabar-logo.txt\",   version = c(1, 0, 0) )"},{"path":"http://parabar.mihaiconstantin.com/reference/make_logo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Package Logo — make_logo","text":"template character string representing path logo template. version numerical vector three positive integers representing version package append logo.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/make_logo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Package Logo — make_logo","text":"ASCII logo.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/make_logo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Package Logo — make_logo","text":"","code":"if (FALSE) { # \\dontrun{  # Generate the logo. logo <- make_logo()  # Print the logo. cat(logo) } # }"},{"path":"http://parabar.mihaiconstantin.com/reference/option.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or Set Package Option — get_option","title":"Get or Set Package Option — get_option","text":"get_option() function helper retrieving value parabar options. option requested available session base::.Options list, corresponding default value set Options R6::R6 class returned instead. set_option() function helper setting parabar options. function adjusts fields Options instance stored base::.Options list. Options instance present base::.Options list, new one created. set_default_options() function used set default options values parabar package. function automatically called package load entry created can retrieved via getOption(\"parabar\"). Specific package options can retrieved using helper function get_option().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/option.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or Set Package Option — get_option","text":"","code":"get_option(option)  set_option(option, value)  set_default_options()"},{"path":"http://parabar.mihaiconstantin.com/reference/option.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or Set Package Option — get_option","text":"option character string representing name option retrieve adjust. See public fields R6::R6 class Options list available parabar options. value value set option .","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/option.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or Set Package Option — get_option","text":"get_option() function returns value requested option present base::.Options list, corresponding default value (.e., see Options). requested option known, error thrown. set_option() function returns void. throws error requested option adjusted known. set_default_options() function returns void. options set can consulted via base::.Options list. See Options R6::R6 class information default values set function.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/option.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or Set Package Option — get_option","text":"","code":"# Get the status of progress tracking. get_option(\"progress_track\") #> [1] TRUE  # Set the status of progress tracking to `FALSE`. set_option(\"progress_track\", FALSE)  # Get the status of progress tracking again. get_option(\"progress_track\") #> [1] FALSE  # Restore default options. set_default_options()  # Get the status of progress tracking yet again. get_option(\"progress_track\") #> [1] TRUE"},{"path":"http://parabar.mihaiconstantin.com/reference/par_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a Task in Parallel — par_apply","title":"Run a Task in Parallel — par_apply","text":"function can used run task parallel. task executed parallel specified backend, similar parallel::parApply(). backend = NULL, task executed sequentially using base::apply(). See Details section information function works.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a Task in Parallel — par_apply","text":"","code":"par_apply(backend = NULL, x, margin, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/par_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a Task in Parallel — par_apply","text":"backend object class Backend returned start_backend() function. can also NULL run task sequentially via base::apply(). default value NULL. x array pass fun function. margin numeric vector indicating dimensions x fun function applied . example, matrix, margin = 1 indicates applying fun rows-wise, margin = 2 indicates applying fun columns-wise, margin = c(1, 2) indicates applying fun element-wise. Named dimensions also possible depending x. See parallel::parApply() base::apply() details. fun function apply x according margin. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_apply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a Task in Parallel — par_apply","text":"dimensions output vary according margin argument. Consult documentation base::apply() detailed explanation output structured.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_apply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a Task in Parallel — par_apply","text":"function uses UserApiConsumer class acts like interface developer API parabar package.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/par_apply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run a Task in Parallel — par_apply","text":"","code":"# \\donttest{  # Define a simple task. task <- function(x) {     # Perform computations.     Sys.sleep(0.01)      # Return the result.     mean(x) }  # Define a matrix for the task. x <- matrix(rnorm(100^2, mean = 10, sd = 0.5), nrow = 100, ncol = 100)  # Start an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Run a task in parallel over the rows of `x`. results <- par_apply(backend, x = x, margin = 1, fun = task)  # Run a task in parallel over the columns of `x`. results <- par_apply(backend, x = x, margin = 2, fun = task)  # The task can also be run over all elements of `x` using `margin = c(1, 2)`. # Improper dimensions will throw an error. try(par_apply(backend, x = x, margin = c(1, 2, 3), fun = task)) #> Error : Margins {1, 2, 3} not compatible with array dimensions {100, 100}.  # Disable progress tracking. set_option(\"progress_track\", FALSE)  # Run a task in parallel. results <- par_apply(backend, x = x, margin = 1, fun = task)  # Enable progress tracking. set_option(\"progress_track\", TRUE)  # Change the progress bar options. configure_bar(type = \"modern\", format = \"[:bar] :percent\")  # Run a task in parallel. results <- par_apply(backend, x = x, margin = 1, fun = task)  # Stop the backend. stop_backend(backend)  # Start a synchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"sync\")  # Run a task in parallel. results <- par_apply(backend, x = x, margin = 1, fun = task) #> Warning: Progress tracking not supported for backend of type 'SyncBackend'.  # Disable progress tracking to remove the warning that progress is not supported. set_option(\"progress_track\", FALSE)  # Run a task in parallel. results <- par_apply(backend, x = x, margin = 1, fun = task)  # Stop the backend. stop_backend(backend)  # Run the task using the `base::lapply` (i.e., non-parallel). results <- par_apply(NULL, x = x, margin = 1, fun = task)  # }"},{"path":"http://parabar.mihaiconstantin.com/reference/par_lapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a Task in Parallel — par_lapply","title":"Run a Task in Parallel — par_lapply","text":"function can used run task parallel. task executed parallel specified backend, similar parallel::parLapply(). backend = NULL, task executed sequentially using base::lapply(). See Details section information function works.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_lapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a Task in Parallel — par_lapply","text":"","code":"par_lapply(backend = NULL, x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/par_lapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a Task in Parallel — par_lapply","text":"backend object class Backend returned start_backend() function. can also NULL run task sequentially via base::lapply(). default value NULL. x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_lapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a Task in Parallel — par_lapply","text":"list length x containing results fun. output format resembles base::lapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_lapply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a Task in Parallel — par_lapply","text":"function uses UserApiConsumer class acts like interface developer API parabar package.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/par_lapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run a Task in Parallel — par_lapply","text":"","code":"# \\donttest{  # Define a simple task. task <- function(x) {     # Perform computations.     Sys.sleep(0.01)      # Return the result.     return(x + 1) }  # Start an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Run a task in parallel. results <- par_lapply(backend, x = 1:300, fun = task)  # Disable progress tracking. set_option(\"progress_track\", FALSE)  # Run a task in parallel. results <- par_lapply(backend, x = 1:300, fun = task)  # Enable progress tracking. set_option(\"progress_track\", TRUE)  # Change the progress bar options. configure_bar(type = \"modern\", format = \"[:bar] :percent\")  # Run a task in parallel. results <- par_lapply(backend, x = 1:300, fun = task)  # Stop the backend. stop_backend(backend)  # Start a synchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"sync\")  # Run a task in parallel. results <- par_lapply(backend, x = 1:300, fun = task) #> Warning: Progress tracking not supported for backend of type 'SyncBackend'.  # Disable progress tracking to remove the warning that progress is not supported. set_option(\"progress_track\", FALSE)  # Run a task in parallel. results <- par_lapply(backend, x = 1:300, fun = task)  # Stop the backend. stop_backend(backend)  # Run the task using the `base::lapply` (i.e., non-parallel). results <- par_lapply(NULL, x = 1:300, fun = task)  # }"},{"path":"http://parabar.mihaiconstantin.com/reference/par_sapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a Task in Parallel — par_sapply","title":"Run a Task in Parallel — par_sapply","text":"function can used run task parallel. task executed parallel specified backend, similar parallel::parSapply(). backend = NULL, task executed sequentially using base::sapply(). See Details section information function works.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_sapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a Task in Parallel — par_sapply","text":"","code":"par_sapply(backend = NULL, x, fun, ...)"},{"path":"http://parabar.mihaiconstantin.com/reference/par_sapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a Task in Parallel — par_sapply","text":"backend object class Backend returned start_backend() function. can also NULL run task sequentially via base::sapply(). default value NULL. x atomic vector list pass fun function. fun function apply element x. ... Additional arguments pass fun function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_sapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a Task in Parallel — par_sapply","text":"vector length x containing results fun. output format resembles base::sapply().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/par_sapply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a Task in Parallel — par_sapply","text":"function uses UserApiConsumer class acts like interface developer API parabar package.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/par_sapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run a Task in Parallel — par_sapply","text":"","code":"# \\donttest{  # Define a simple task. task <- function(x) {     # Perform computations.     Sys.sleep(0.01)      # Return the result.     return(x + 1) }  # Start an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Run a task in parallel. results <- par_sapply(backend, x = 1:300, fun = task)  # Disable progress tracking. set_option(\"progress_track\", FALSE)  # Run a task in parallel. results <- par_sapply(backend, x = 1:300, fun = task)  # Enable progress tracking. set_option(\"progress_track\", TRUE)  # Change the progress bar options. configure_bar(type = \"modern\", format = \"[:bar] :percent\")  # Run a task in parallel. results <- par_sapply(backend, x = 1:300, fun = task)  # Stop the backend. stop_backend(backend)  # Start a synchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"sync\")  # Run a task in parallel. results <- par_sapply(backend, x = 1:300, fun = task) #> Warning: Progress tracking not supported for backend of type 'SyncBackend'.  # Disable progress tracking to remove the warning that progress is not supported. set_option(\"progress_track\", FALSE)  # Run a task in parallel. results <- par_sapply(backend, x = 1:300, fun = task)  # Stop the backend. stop_backend(backend)  # Run the task using the `base::sapply` (i.e., non-parallel). results <- par_sapply(NULL, x = 1:300, fun = task)  # }"},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Progress Bar for Parallel Tasks — parabar-package","title":"Progress Bar for Parallel Tasks — parabar-package","text":"simple interface form R6 classes executing tasks parallel, tracking progress, displaying accurate progress bars.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Progress Bar for Parallel Tasks — parabar-package","text":"package aimed two audiences: (1) end-users want execute task parallel interactive R session track execution progress, (2) R package developers want use parabar solution parallel processing packages.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":"users","dir":"Reference","previous_headings":"","what":"Users","title":"Progress Bar for Parallel Tasks — parabar-package","text":"first category users, parabar provides several main functions interest: start_backend(): creates parallel backend executing tasks according specifications provided. stop_backend(): stops active backend makes R6::R6 eligible garbage collection. par_sapply(): drop-replacement built-base::sapply() function backend provided. However, backend provided, function execute task parallel backend, similar built-function parallel::parSapply(). par_lapply(): drop-replacement built-base::lapply() function backend provided. However, backend provided, function execute task parallel backend, similar built-function parallel::parLapply(). par_apply(): drop-replacement built-base::apply() function backend provided. However, backend provided, function execute task parallel backend, similar built-function parallel::parApply(). clear(): removes variables available backend. peek(): returns names variables available backend. export(): exports objects specified environment backend. evaluate(): evaluates arbitrary unquoted expression backend. parabar also provides function configure_bar() configuring progress bar, three functions can used get set package options: get_option(): gets value package option. set_option(): sets value package option. set_default_options(): sets default values package options. function automatically called package load.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":"developers","dir":"Reference","previous_headings":"","what":"Developers","title":"Progress Bar for Parallel Tasks — parabar-package","text":"second category users, parabar provides set classes (.e., R6::R6Class()) can used create backends (.e., synchronous asynchronous) interact via simple interface. high-level perspective, package consists backends contexts backends employed executing tasks parallel.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":"backends","dir":"Reference","previous_headings":"","what":"Backends","title":"Progress Bar for Parallel Tasks — parabar-package","text":"backend represents set operations, defined BackendService interface, can deployed cluster returned parallel::makeCluster(). Backends can synchronous (.e., SyncBackend) asynchronous (.e., AsyncBackend). former block execution current R session parallel task completed, latter return immediately task executed background R session. BackendService interface defines following operations: start(), stop(), clear(), peek(), export(), evaluate(), sapply(), lapply(), apply(), get_output(). Check documentation BackendService information method.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":"contexts","dir":"Reference","previous_headings":"","what":"Contexts","title":"Progress Bar for Parallel Tasks — parabar-package","text":"context represents specific conditions backend operates. default, regular Context class simply forwards call corresponding backend method. However, complex context can augment operation forwarding call backend. One example complex context ProgressTrackingContext class. class extends regular Context class decorates, example, backend sapply() operation log progress task execution display progress bar. following main classes provided parabar: BackendService: interface backend operations. Backend: abstract class serves base class concrete implementations. SyncBackend: synchronous backend extending abstract Backend class. AsyncBackend: asynchronous backend extending abstract Backend class. Specification: backend specification used starting backend. TaskState: determine state task deployed asynchronous backend. BackendFactory: factory creating backend objects. Context: default context executing backend operations. ProgressTrackingContext: context decorating sapply(), lapply(), apply() operations track display execution progress. ContextFactory: factory creating context objects. UserApiConsumer: opinionated wrapper around R6::R6 classes used exported functions users.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":"progress-bars","dir":"Reference","previous_headings":"","what":"Progress Bars","title":"Progress Bar for Parallel Tasks — parabar-package","text":"parabar also exposes several classes creating updating different progress bars, namely: Bar: abstract class defining pure virtual methods implemented concrete bar classes. BasicBar: simple, robust, bar created via utils::txtProgressBar() extending Bar abstract class. ModernBar: modern bar created via progress::progress_bar extending Bar abstract class. BarFactory: factory creating bar objects. Finally, parabar uses several base::options() configure behavior functionality provides. information options used see default values, see Options class. information design parabar, check documentation UML diagram parabar.mihaiconstantin.com.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/parabar-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Progress Bar for Parallel Tasks — parabar-package","text":"Maintainer: Mihai Constantin mihai@mihaiconstantin.com (ORCID)","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/peek.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect a Backend — peek","title":"Inspect a Backend — peek","text":"function can used check names variables present backend created start_backend().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/peek.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect a Backend — peek","text":"","code":"peek(backend)"},{"path":"http://parabar.mihaiconstantin.com/reference/peek.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect a Backend — peek","text":"backend object class Backend returned start_backend() function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/peek.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect a Backend — peek","text":"function returns list character vectors, list element corresponds node, element character vector name variable present node. throws error value provided backend argument instance class Backend.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/peek.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inspect a Backend — peek","text":"function convenience wrapper around lower-lever API parabar aimed developers. specifically, function calls peek method provided backend instance.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/peek.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect a Backend — peek","text":"","code":"# Create an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Check that the backend is active. backend$active #> [1] TRUE  # Check if there is anything on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the `name` variable in the current environment to the backend. export(backend, \"name\", environment())  # Remove the dummy variable from the current environment. rm(name)  # Check the backend to see that the variable has been exported. peek(backend) #> [[1]] #> [1] \"name\" #>  #> [[2]] #> [1] \"name\" #>   # Run an expression on the backend. # Note that the symbols in the expression are resolved on the backend. evaluate(backend, {     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Clear the backend. clear(backend)  # Check that there is nothing on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Use a basic progress bar (i.e., see `parabar::Bar`). configure_bar(type = \"basic\", style = 3)  # Run a task in parallel (i.e., approx. 1.25 seconds). output <- par_sapply(backend, x = 1:10, fun = function(x) {     # Sleep a bit.     Sys.sleep(0.25)      # Compute and return.     return(x + 1) })  # Print the output. print(output) #>  [1]  2  3  4  5  6  7  8  9 10 11  # Stop the backend. stop_backend(backend)  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":null,"dir":"Reference","previous_headings":"","what":"Start a Backend — start_backend","title":"Start a Backend — start_backend","text":"function can used start backend. Check Details section information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start a Backend — start_backend","text":"","code":"start_backend(cores, cluster_type = \"psock\", backend_type = \"async\")"},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start a Backend — start_backend","text":"cores positive integer representing number cores use (.e., number processes start). value must 2 parallel::detectCores() - 1. cluster_type character string representing type cluster create. Possible values \"fork\" \"psock\". Defaults \"psock\". See section Cluster Type information. backend_type character string representing type backend create. Possible values \"sync\" \"async\". Defaults \"async\". See section Backend Type information.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start a Backend — start_backend","text":"Backend instance can used parallelize computations. methods available Backend instance defined BackendService interface.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Start a Backend — start_backend","text":"function convenience wrapper around lower-lever API parabar aimed developers. specifically, function uses Specification class create specification object, BackendFactory class create Backend instance based specification object.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":"cluster-type","dir":"Reference","previous_headings":"","what":"Cluster Type","title":"Start a Backend — start_backend","text":"cluster type determines type cluster create. requested value validated passed type argument parallel::makeCluster() function. following table lists possible values corresponding description.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":"backend-type","dir":"Reference","previous_headings":"","what":"Backend Type","title":"Start a Backend — start_backend","text":"backend type determines type backend create. requested value passed BackendFactory class, returns Backend instance desired type. following table lists possible backend types corresponding description. nutshell, difference two backend types synchronous backend cluster created main process, asynchronous backend cluster created backend R process using callr::r_session. Therefore, synchronous backend blocking main process task execution, asynchronous backend non-blocking. Check implementations listed table information. concrete implementations extend Backend abstract class implement BackendService interface.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/start_backend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start a Backend — start_backend","text":"","code":"# Create an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Check that the backend is active. backend$active #> [1] TRUE  # Check if there is anything on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the `name` variable in the current environment to the backend. export(backend, \"name\", environment())  # Remove the dummy variable from the current environment. rm(name)  # Check the backend to see that the variable has been exported. peek(backend) #> [[1]] #> [1] \"name\" #>  #> [[2]] #> [1] \"name\" #>   # Run an expression on the backend. # Note that the symbols in the expression are resolved on the backend. evaluate(backend, {     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Clear the backend. clear(backend)  # Check that there is nothing on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Use a basic progress bar (i.e., see `parabar::Bar`). configure_bar(type = \"basic\", style = 3)  # Run a task in parallel (i.e., approx. 1.25 seconds). output <- par_sapply(backend, x = 1:10, fun = function(x) {     # Sleep a bit.     Sys.sleep(0.25)      # Compute and return.     return(x + 1) })  # Print the output. print(output) #>  [1]  2  3  4  5  6  7  8  9 10 11  # Stop the backend. stop_backend(backend)  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/reference/stop_backend.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop a Backend — stop_backend","title":"Stop a Backend — stop_backend","text":"function can used stop backend created start_backend().","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/stop_backend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop a Backend — stop_backend","text":"","code":"stop_backend(backend)"},{"path":"http://parabar.mihaiconstantin.com/reference/stop_backend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stop a Backend — stop_backend","text":"backend object class Backend returned start_backend() function.","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/stop_backend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stop a Backend — stop_backend","text":"function returns void. throws error : value provided backend argument instance class Backend. backend object provided already stopped (.e., active).","code":""},{"path":"http://parabar.mihaiconstantin.com/reference/stop_backend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stop a Backend — stop_backend","text":"function convenience wrapper around lower-lever API parabar aimed developers. specifically, function calls stop method provided backend instance.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/reference/stop_backend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stop a Backend — stop_backend","text":"","code":"# Create an asynchronous backend. backend <- start_backend(cores = 2, cluster_type = \"psock\", backend_type = \"async\")  # Check that the backend is active. backend$active #> [1] TRUE  # Check if there is anything on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Create a dummy variable. name <- \"parabar\"  # Export the `name` variable in the current environment to the backend. export(backend, \"name\", environment())  # Remove the dummy variable from the current environment. rm(name)  # Check the backend to see that the variable has been exported. peek(backend) #> [[1]] #> [1] \"name\" #>  #> [[2]] #> [1] \"name\" #>   # Run an expression on the backend. # Note that the symbols in the expression are resolved on the backend. evaluate(backend, {     # Print the name.     print(paste0(\"Hello, \", name, \"!\")) }) #> [[1]] #> [1] \"Hello, parabar!\" #>  #> [[2]] #> [1] \"Hello, parabar!\" #>   # Clear the backend. clear(backend)  # Check that there is nothing on the backend. peek(backend) #> [[1]] #> character(0) #>  #> [[2]] #> character(0) #>   # Use a basic progress bar (i.e., see `parabar::Bar`). configure_bar(type = \"basic\", style = 3)  # Run a task in parallel (i.e., approx. 1.25 seconds). output <- par_sapply(backend, x = 1:10, fun = function(x) {     # Sleep a bit.     Sys.sleep(0.25)      # Compute and return.     return(x + 1) })  # Print the output. print(output) #>  [1]  2  3  4  5  6  7  8  9 10 11  # Stop the backend. stop_backend(backend)  # Check that the backend is not active. backend$active #> [1] FALSE"},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"parabar-121","dir":"Changelog","previous_headings":"","what":"parabar 1.2.1","title":"parabar 1.2.1","text":"CRAN release: 2024-10-17","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-1-2-1","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 1.2.1","text":"Update URL status 301 README.md per CRAN checks.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-1-2-0","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 1.2.0","text":"Enable roxygen checks R6 documentation DESCRIPTION. Update Context implement Service interface. Update GitHub workflows. Fix typos errors code documentation.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"parabar-111","dir":"Changelog","previous_headings":"","what":"parabar 1.1.1","title":"parabar 1.1.1","text":"CRAN release: 2024-02-05","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"added-1-1-1","dir":"Changelog","previous_headings":"","what":"Added","title":"parabar 1.1.1","text":"Add tests progress tracking context executed tasks throw error. relation #44.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-1-1-1","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 1.1.1","text":"Update action versions GitHub workflows.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-1-1-1","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 1.1.1","text":"Fix hanging progress bar errors ProgressTrackingContext.R class. Closes #44. Remove duplicated lines UserApiConsumer class. Closes #41. Fix indentation UML design diagram. Closes #45. Add missing apply operation README documentation.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"parabar-110","dir":"Changelog","previous_headings":"","what":"parabar 1.1.0","title":"parabar 1.1.0","text":"CRAN release: 2023-05-07","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"added-1-1-0","dir":"Changelog","previous_headings":"","what":"Added","title":"parabar 1.1.0","text":"Update implementations Service$apply operation Backend classes validate provided margin argument running parallel operation. Add helper Helper$check_array_margins validate margins provided Service$apply operation. Add exception Exception$array_margins_not_compatible using improper margins Service$apply operation. Add exception Exception$primitive_as_task_not_allowed trying decorate primitive functions progress tracking ProgressTrackingContext class. Add helper Helper$is_of_class check object given class. Add optional arguments get_output operation SyncBackend consistency. Add tests improve coverage. Add implementation Service$lapply Service$apply operations classes implement Service interface. Add par_lapply par_apply functions user API. functions can used run tasks parallel akin parallel::parLapply parallel::parApply, respectively. Add UserApiConsumer R6 class provides opinionated wrapper around developer API parabar package. parallel operations (e.g., par_sapply par_lapply) follow less pattern. UserApiConsumer encapsulates pattern makes easier extend parabar new parallel functions (e.g., par_apply) avoiding code duplication. UserApiConsumer class can also used standalone class parallel operations, however, primary purpose used parallel task execution functions user API.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-1-1-0","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 1.1.0","text":"Force early evaluation x argument task execution functions ProgressTrackingContext class. Update log file progress tracking include parabar file name. Disable warnings file.create ProgressTrackingContext class. warning superfluous since code handles creation failures. Refactor test helpers avoid code duplication. Update par_sapply use UserApiConsumer class. Update developer API R6 classes implement lapply parallel operation.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-1-1-0","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 1.1.0","text":"Ensure task execution errors propagated main session AsyncBackend. Closes #35. Fixed rendering CC 4.0 license icons README.md package website. Update .decorate method ProgressTrackingContext flexible. specifically, method now throw primitive functions provided decoration. method can now handle inline functions (.e., function(x) x) functions body defined terms compound expressions (.e., function(x) { x }). Closes #32. Fix export operation SyncBackend Context classes fallback parent environment argument environment provided.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"parabar-103","dir":"Changelog","previous_headings":"","what":"parabar 1.0.3","title":"parabar 1.0.3","text":"CRAN release: 2023-04-24","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-1-0-3","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 1.0.3","text":"Fixed moved URL package NEWS.md per CRAN request.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-1-0-2","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 1.0.2","text":"Fixed URLs package documentation per CRAN request.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-1-0-1","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 1.0.1","text":"Update logo version v0.x.x v1.x.x.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"added-1-0-0","dir":"Changelog","previous_headings":"","what":"Added","title":"parabar 1.0.0","text":"Add CC 4.0 license package documentation, vignettes, website content. Add code coverage GitHub workflow via codecov badge README. Add tests end-user API developer API. Add vignette comparison.Rmd compare parabar pbapply package, provide rough benchmarks. comparison.Rmd vignette locally build comparison.Rmd.orig file (.e., see resource information). Add active biding Options$progress_log_path handle generation temporary files tracking execution progress tasks ran parallel. Using custom path (e.g., debugging) also possible setting active binding desired path.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-1-0-0","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 1.0.0","text":"Refactor Specification testing purposes. Replace \\dontrun{} statements examples try() calls. Update example Options class feature progress_log_path active binding. Update progress logging injection approach .decorate method ProgressTrackingContext use bquote instead substitute. Breaking. Rename class ProgressDecorator ProgressTrackingContext consistent idea backends run contexts. Add ... optional arguments signature get_output method Service interface. Update private method .make_log ProgressDecorator use progress_log_path option. Update UML diagram include missing classes changed methods. Also updated corresponding diagram figure package documentation.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-1-0-0","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 1.0.0","text":"Update Specification prevent incompatible cluster types (e.g., FORK) Windows platforms. cases, warning issues cluster type defaults PSOCK. Ensure make_logo can ran platforms.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-0-10-2","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 0.10.2","text":"Update README add CRAN installation instructions new badges.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-0-10-2","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 0.10.2","text":"Corrected expression files folders `.Rbuildignore.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"parabar-0101","dir":"Changelog","previous_headings":"","what":"parabar 0.10.1","title":"parabar 0.10.1","text":"CRAN release: 2023-02-28","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-0-10-1","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 0.10.1","text":"Initially removed \\dontrun{} make_logo function examples per CRAN request commit 87678fe. However, results examples failing R-CMD-check workflow. Reverted change commit a9d11ac. Update version constant LOGO v1.x.x v0.x.x.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-0-10-1","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 0.10.1","text":"Add missing environment examples SyncBackend class.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"added-0-10-0","dir":"Changelog","previous_headings":"","what":"Added","title":"parabar 0.10.0","text":"Add new exported wrappers pkgdown reference section. clear: clean provided backend instance. export: export variables given environment .GlobalEnv backend instance. peek: list variables names available backend instance. evaluate: evaluate arbitrary expressions backend instance. Add type checks exported functions (.e., user API). Add helper method checking validating type object. Helper$check_object_type method checks type object matches expected type. case, helper throws error (.e., Exception$type_not_assignable).","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-0-10-0","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 0.10.0","text":"Add .scss styles override table column width exported wrappers table pkgdown website. Update README package documentation mention new exported wrappers. Update order topics website reference section generated via pkgdown. Update roxygen2 @examples exported wrappers. code examples located documentation start_backend function. exported wrappers (.e., clear, export, peek, evaluate, par_sapply) inherit @examples section start_backend. Update references @seealso documentation sections. Change backend argument par_sapply backend = NULL. implies, par_sapply without backend behaves identically base::sapply.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-0-10-0","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 0.10.0","text":"Update export method use .GlobalEnv fallback exporting variables.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"added-0-9-4","dir":"Changelog","previous_headings":"","what":"Added","title":"parabar 0.9.4","text":"Add custom styles extra.scss improve documentation website. Add S3 print method LOGO object.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-0-9-4","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 0.9.4","text":"Improve documentation exported objects. Merge documentations get_option, set_option, set_default_options. Improved README. specifically, added description Service interface methods enabled documentation linking (.e., via ?) pkgdown website.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-0-9-4","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 0.9.4","text":"Add missing export Options class. Ensure examples ProgressBar use wait = TRUE fetching output. Fix bug evaluate backend operation. expression passed evaluate correctly passed function chain parallel::clusterCall. See question StackOverflow clarifications. Closes #9.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"changed-0-9-3","dir":"Changelog","previous_headings":"","what":"Changed","title":"parabar 0.9.3","text":"Change type private field .bar_config ProgressDecorator class list. way, configure_bar() method ProgressBar class becomes optional step.","code":""},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-0-9-3","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 0.9.3","text":"Implement file locking logging progress child processes avoid race conditions. implementation based filelock package. Closes #8. Fix typo DESCRIPTION.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-0-9-2","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 0.9.2","text":"Update man-roxygen/parabar.R \\html{...} fix HTML validation errors. Closes #6. Fix package description DESCRIPTION file comply CRAN requirements.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"fixed-0-9-1","dir":"Changelog","previous_headings":"","what":"Fixed","title":"parabar 0.9.1","text":"Update broken links README file. Disable examples par_sapply exported function due exceeding CRAN time limit running examples.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"added-0-9-0","dir":"Changelog","previous_headings":"","what":"Added","title":"parabar 0.9.0","text":"Add package website via pkgdown GitHub pages. Add GitHub workflow automatically check package several platforms R versions. Export R6 classes developer API regenerate namespace. Add preliminary package documentation README file. Add exported wrapper par_sapply run tasks parallel display progress bar appropriate. Add exported wrapper stop_backend stop backend instance. Add exported wrapper start_backend create backend instance based specified specification. Add exported wrapper configure_bar configuring type behavior progress bar. Add exported wrapper set_option Helper$set_option. function available end-users can used set value specific option. Add helper method setting package options. static method Helper$set_option wrapper around base::getOption sets value specific option exists, throws error otherwise. Add package object documentation relevant information DESCRIPTION file. Add parabar logo startup message interactive R sessions. Add function generate package logo based ASCII template inst/assets/logo/parabar-logo.txt. Add exported wrapper get_option Helper$get_option. function available end-users can used get value specific option default value. Add helper method getting package options defaults. static method Helper$get_option wrapper around base::getOption returns value specific option exists, default value set Options class otherwise. Add Options R6 class set_default_options function manage package options parabar. documented fields Options class represent options can configured user. set_default_options function can used set default package options automatically run package load time. nutshell, set_default_options stores instance Options base::.Options list key parabar. Implement initial software design. helicopter view, design consists backend context objects. backend represents set operations can deployed cluster produced parallel::makeCluster. backend, therefore, interacts cluster via specific operations defined Service interface. context represents specific conditions backend operations invoked. regular context object simply forwards call corresponding backend method. However, complex context can augment operation invoking backend operation. One example complex context ProgressDecorator class. class extends regular Context class decorates backend sapply operation provide progress tracking display progress bar. Context: represents regular context wraps backend objects. words, Service methods calls implemented context forwarded corresponding methods implemented backend object. ProgressDecorator: represents progress tracking context. context decorates sapply method available backend instance log progress task execution display progress bar. ContextFactory: represents blueprint obtaining specific context instances. Service: represents interface concrete backends must implement. contains methods (.e., operations) can requested given backend instance. methods form main API parabar. Backend: represents abstract class implements Service interface. contains fields methods relevant concrete backend implementations extend class. SyncBackend: represents concrete implementation synchronous backend. executing task parallel via sapply method, caller process (.e., usually interactive R session) blocked task finishes executing. AsyncBackend: represents concrete implementation asynchronous backend. lunching task parallel via sapply method, method returns immediately leaving caller process (e.g., interactive R session) free. computation task offloaded permanent background R session. One can read state task using public field (.e., active binding) task_state. Furthermore, results can fetched background session using get_output method, can either block main process wait results, attempt fetch immediately throw error successful. Specification: represents auxiliary class encapsulates logic determining type cluster create (.e., via parallel::makeCluster), number nodes (.e., R processes) cluster. TaskState: represents auxiliary class encapsulates logic determining state task. BackendFactory: represents blueprint obtaining concrete backend implementations. Add Helper, Warning, Exception R6 classes. classes contain static member methods provide useful utilities, handle warning messages, throw informative errors, respectively. Add UML diagram package classes. classes provided parabar can split three categories, namely (1) backend classes responsible managing clusters, (2) context classes decorate backend objects additional functionality (e.g., progress tracking), (3) progress bar classes providing common interface creating interacting various progress bars.","code":""},{"path":[]},{"path":"http://parabar.mihaiconstantin.com/news/index.html","id":"added-0-1-0","dir":"Changelog","previous_headings":"","what":"Added","title":"parabar 0.1.0","text":"Add Bar abstraction working progress bars R. Currently, two types progress bars supported (.e., BasicBar ModernBar). BasicBar uses engine utils::txtProgressBar, ModernBar relies R6 class obtained progress::progress_bar. Specific concrete instances bar types can requested BarFactory.","code":""}]
